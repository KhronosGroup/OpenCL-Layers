<?xml version="1.0" encoding="UTF-8"?>
<registry>
    <!-- SECTION: OpenCL API interface definitions -->
    <feature api="opencl" name="CL_VERSION_1_0" number="1.0" comment="OpenCL core API interface definitions">
        <require comment="Header boilerplate">
            <type name="CL/cl_version.h"/>
            <type name="CL/cl_platform.h"/>
        </require>
        <require comment="API types">
            <type name="cl_platform_id"/>
            <type name="cl_device_id"/>
            <type name="cl_context"/>
            <type name="cl_command_queue"/>
            <type name="cl_mem"/>
            <type name="cl_program"/>
            <type name="cl_kernel"/>
            <type name="cl_event"/>
            <type name="cl_sampler"/>
            <type name="cl_bool" comment="WARNING! Unlike cl_ types in cl_platform.h, cl_bool is not guaranteed to be the same size as the bool in kernels."/>
            <type name="cl_bitfield"/>
            <type name="cl_device_type"/>
            <type name="cl_platform_info"/>
            <type name="cl_device_info"/>
            <type name="cl_device_fp_config"/>
            <type name="cl_device_mem_cache_type"/>
            <type name="cl_device_local_mem_type"/>
            <type name="cl_device_exec_capabilities"/>
            <type name="cl_command_queue_properties"/>
            <type name="cl_context_properties"/>
            <type name="cl_context_info"/>
            <type name="cl_command_queue_info"/>
            <type name="cl_channel_order"/>
            <type name="cl_channel_type"/>
            <type name="cl_mem_flags"/>
            <type name="cl_mem_object_type"/>
            <type name="cl_mem_info"/>
            <type name="cl_image_info"/>
            <type name="cl_addressing_mode"/>
            <type name="cl_filter_mode"/>
            <type name="cl_sampler_info"/>
            <type name="cl_map_flags"/>
            <type name="cl_program_info"/>
            <type name="cl_program_build_info"/>
            <type name="cl_build_status"/>
            <type name="cl_kernel_info"/>
            <type name="cl_kernel_work_group_info"/>
            <type name="cl_event_info"/>
            <type name="cl_command_type"/>
            <type name="cl_profiling_info"/>
            <type name="cl_image_format"/>
            <type name="cl_buffer_region"/>
        </require>
        <require comment="Constants">
            <enum name="CL_CHAR_BIT"/>
            <enum name="CL_CHAR_MAX"/>
            <enum name="CL_CHAR_MIN"/>
            <enum name="CL_UCHAR_MAX"/>
            <enum name="CL_SCHAR_MAX"/>
            <enum name="CL_SCHAR_MIN"/>
            <enum name="CL_SHRT_MAX"/>
            <enum name="CL_SHRT_MIN"/>
            <enum name="CL_USHRT_MAX"/>
            <enum name="CL_INT_MAX"/>
            <enum name="CL_INT_MIN"/>
            <enum name="CL_UINT_MAX"/>
            <enum name="CL_LONG_MAX"/>
            <enum name="CL_LONG_MIN"/>
            <enum name="CL_ULONG_MAX"/>
            <enum name="CL_FLT_DIG"/>
            <enum name="CL_FLT_MANT_DIG"/>
            <enum name="CL_FLT_MAX_10_EXP"/>
            <enum name="CL_FLT_MAX_EXP"/>
            <enum name="CL_FLT_MIN_10_EXP"/>
            <enum name="CL_FLT_MIN_EXP"/>
            <enum name="CL_FLT_RADIX"/>
            <enum name="CL_FLT_MAX"/>
            <enum name="CL_FLT_MIN"/>
            <enum name="CL_FLT_EPSILON"/>
            <enum name="CL_DBL_DIG"/>
            <enum name="CL_DBL_MANT_DIG"/>
            <enum name="CL_DBL_MAX_10_EXP"/>
            <enum name="CL_DBL_MAX_EXP"/>
            <enum name="CL_DBL_MIN_10_EXP"/>
            <enum name="CL_DBL_MIN_EXP"/>
            <enum name="CL_DBL_RADIX"/>
            <enum name="CL_DBL_MAX"/>
            <enum name="CL_DBL_MIN"/>
            <enum name="CL_DBL_EPSILON"/>
            <enum name="CL_NAN"/>
            <enum name="CL_HUGE_VALF"/>
            <enum name="CL_HUGE_VAL"/>
            <enum name="CL_MAXFLOAT"/>
            <enum name="CL_INFINITY"/>
        </require>
        <require comment="Error codes">
            <enum name="CL_SUCCESS"/>
            <enum name="CL_DEVICE_NOT_FOUND"/>
            <enum name="CL_DEVICE_NOT_AVAILABLE"/>
            <enum name="CL_COMPILER_NOT_AVAILABLE"/>
            <enum name="CL_MEM_OBJECT_ALLOCATION_FAILURE"/>
            <enum name="CL_OUT_OF_RESOURCES"/>
            <enum name="CL_OUT_OF_HOST_MEMORY"/>
            <enum name="CL_PROFILING_INFO_NOT_AVAILABLE"/>
            <enum name="CL_MEM_COPY_OVERLAP"/>
            <enum name="CL_IMAGE_FORMAT_MISMATCH"/>
            <enum name="CL_IMAGE_FORMAT_NOT_SUPPORTED"/>
            <enum name="CL_BUILD_PROGRAM_FAILURE"/>
            <enum name="CL_MAP_FAILURE"/>
            <enum name="CL_INVALID_VALUE"/>
            <enum name="CL_INVALID_DEVICE_TYPE"/>
            <enum name="CL_INVALID_PLATFORM"/>
            <enum name="CL_INVALID_DEVICE"/>
            <enum name="CL_INVALID_CONTEXT"/>
            <enum name="CL_INVALID_QUEUE_PROPERTIES"/>
            <enum name="CL_INVALID_COMMAND_QUEUE"/>
            <enum name="CL_INVALID_HOST_PTR"/>
            <enum name="CL_INVALID_MEM_OBJECT"/>
            <enum name="CL_INVALID_IMAGE_FORMAT_DESCRIPTOR"/>
            <enum name="CL_INVALID_IMAGE_SIZE"/>
            <enum name="CL_INVALID_SAMPLER"/>
            <enum name="CL_INVALID_BINARY"/>
            <enum name="CL_INVALID_BUILD_OPTIONS"/>
            <enum name="CL_INVALID_PROGRAM"/>
            <enum name="CL_INVALID_PROGRAM_EXECUTABLE"/>
            <enum name="CL_INVALID_KERNEL_NAME"/>
            <enum name="CL_INVALID_KERNEL_DEFINITION"/>
            <enum name="CL_INVALID_KERNEL"/>
            <enum name="CL_INVALID_ARG_INDEX"/>
            <enum name="CL_INVALID_ARG_VALUE"/>
            <enum name="CL_INVALID_ARG_SIZE"/>
            <enum name="CL_INVALID_KERNEL_ARGS"/>
            <enum name="CL_INVALID_WORK_DIMENSION"/>
            <enum name="CL_INVALID_WORK_GROUP_SIZE"/>
            <enum name="CL_INVALID_WORK_ITEM_SIZE"/>
            <enum name="CL_INVALID_GLOBAL_OFFSET"/>
            <enum name="CL_INVALID_EVENT_WAIT_LIST"/>
            <enum name="CL_INVALID_EVENT"/>
            <enum name="CL_INVALID_OPERATION"/>
            <enum name="CL_INVALID_GL_OBJECT"/>
            <enum name="CL_INVALID_BUFFER_SIZE"/>
            <enum name="CL_INVALID_MIP_LEVEL"/>
            <enum name="CL_INVALID_GLOBAL_WORK_SIZE"/>
        </require>
        <require comment="cl_bool">
            <enum name="CL_FALSE"/>
            <enum name="CL_TRUE"/>
        </require>
        <require comment="cl_platform_info">
            <enum name="CL_PLATFORM_PROFILE" return_type="char[]"/>
            <enum name="CL_PLATFORM_VERSION" return_type="char[]"/>
            <enum name="CL_PLATFORM_NAME" return_type="char[]"/>
            <enum name="CL_PLATFORM_VENDOR" return_type="char[]"/>
            <enum name="CL_PLATFORM_EXTENSIONS" return_type="char[]"/>
        </require>
        <require comment="cl_device_type - bitfield">
            <enum name="CL_DEVICE_TYPE_DEFAULT"/>
            <enum name="CL_DEVICE_TYPE_CPU"/>
            <enum name="CL_DEVICE_TYPE_GPU"/>
            <enum name="CL_DEVICE_TYPE_ACCELERATOR"/>
            <enum name="CL_DEVICE_TYPE_ALL"/>
        </require>
        <require comment="cl_device_info">
            <enum name="CL_DEVICE_TYPE" return_type="cl_device_type"/>
            <enum name="CL_DEVICE_VENDOR_ID" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_COMPUTE_UNITS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_WORK_GROUP_SIZE" return_type="size_t"/>
            <enum name="CL_DEVICE_MAX_WORK_ITEM_SIZES" return_type="size_t[]"/>
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_CLOCK_FREQUENCY" return_type="cl_uint"/>
            <enum name="CL_DEVICE_ADDRESS_BITS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_READ_IMAGE_ARGS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_WRITE_IMAGE_ARGS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_MEM_ALLOC_SIZE" return_type="cl_ulong"/>
            <enum name="CL_DEVICE_IMAGE2D_MAX_WIDTH" return_type="size_t"/>
            <enum name="CL_DEVICE_IMAGE2D_MAX_HEIGHT" return_type="size_t"/>
            <enum name="CL_DEVICE_IMAGE3D_MAX_WIDTH" return_type="size_t"/>
            <enum name="CL_DEVICE_IMAGE3D_MAX_HEIGHT" return_type="size_t"/>
            <enum name="CL_DEVICE_IMAGE3D_MAX_DEPTH" return_type="size_t"/>
            <enum name="CL_DEVICE_IMAGE_SUPPORT" return_type="cl_bool"/>
            <enum name="CL_DEVICE_MAX_PARAMETER_SIZE" return_type="size_t"/>
            <enum name="CL_DEVICE_MAX_SAMPLERS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MEM_BASE_ADDR_ALIGN" return_type="cl_uint"/>
            <enum name="CL_DEVICE_SINGLE_FP_CONFIG" return_type="cl_device_fp_config"/>
            <enum name="CL_DEVICE_GLOBAL_MEM_CACHE_TYPE" return_type="cl_device_mem_cache_type"/>
            <enum name="CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE" return_type="cl_uint"/>
            <enum name="CL_DEVICE_GLOBAL_MEM_CACHE_SIZE" return_type="cl_ulong"/>
            <enum name="CL_DEVICE_GLOBAL_MEM_SIZE" return_type="cl_ulong"/>
            <enum name="CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE" return_type="cl_ulong"/>
            <enum name="CL_DEVICE_MAX_CONSTANT_ARGS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_LOCAL_MEM_TYPE" return_type="cl_device_local_mem_type"/>
            <enum name="CL_DEVICE_LOCAL_MEM_SIZE" return_type="cl_ulong"/>
            <enum name="CL_DEVICE_ERROR_CORRECTION_SUPPORT" return_type="cl_bool"/>
            <enum name="CL_DEVICE_PROFILING_TIMER_RESOLUTION" return_type="size_t"/>
            <enum name="CL_DEVICE_ENDIAN_LITTLE" return_type="cl_bool"/>
            <enum name="CL_DEVICE_AVAILABLE" return_type="cl_bool"/>
            <enum name="CL_DEVICE_COMPILER_AVAILABLE" return_type="cl_bool"/>
            <enum name="CL_DEVICE_EXECUTION_CAPABILITIES" return_type="cl_device_exec_capabilities"/>
            <enum name="CL_DEVICE_NAME" return_type="char[]"/>
            <enum name="CL_DEVICE_VENDOR" return_type="char[]"/>
            <enum name="CL_DRIVER_VERSION" return_type="char[]"/>
            <enum name="CL_DEVICE_PROFILE" return_type="char[]"/>
            <enum name="CL_DEVICE_VERSION" return_type="char[]"/>
            <enum name="CL_DEVICE_EXTENSIONS" return_type="char[]"/>
            <enum name="CL_DEVICE_PLATFORM" return_type="cl_platform_id"/>
        </require>
        <require comment="cl_device_fp_config - bitfield">
            <enum name="CL_FP_DENORM"/>
            <enum name="CL_FP_INF_NAN"/>
            <enum name="CL_FP_ROUND_TO_NEAREST"/>
            <enum name="CL_FP_ROUND_TO_ZERO"/>
            <enum name="CL_FP_ROUND_TO_INF"/>
            <enum name="CL_FP_FMA"/>
        </require>
        <require comment="cl_device_mem_cache_type">
            <enum name="CL_NONE"/>
            <enum name="CL_READ_ONLY_CACHE"/>
            <enum name="CL_READ_WRITE_CACHE"/>
        </require>
        <require comment="cl_device_local_mem_type">
            <enum name="CL_LOCAL"/>
            <enum name="CL_GLOBAL"/>
        </require>
        <require comment="cl_device_exec_capabilities - bitfield">
            <enum name="CL_EXEC_KERNEL"/>
            <enum name="CL_EXEC_NATIVE_KERNEL"/>
        </require>
        <require comment="cl_command_queue_properties - bitfield">
            <enum name="CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE"/>
            <enum name="CL_QUEUE_PROFILING_ENABLE"/>
        </require>
        <require comment="cl_context_info">
            <enum name="CL_CONTEXT_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_CONTEXT_DEVICES" return_type="cl_device_id[]"/>
            <enum name="CL_CONTEXT_PROPERTIES" return_type="cl_context_properties[]"/>
        </require>
        <require comment="cl_context_properties">
            <enum name="CL_CONTEXT_PLATFORM"/>
        </require>
        <require comment="cl_command_queue_info">
            <enum name="CL_QUEUE_CONTEXT" return_type="cl_context"/>
            <enum name="CL_QUEUE_DEVICE" return_type="cl_device_id"/>
            <enum name="CL_QUEUE_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_QUEUE_PROPERTIES" return_type="cl_command_queue_properties"/>
        </require>
        <require comment="cl_mem_flags and cl_svm_mem_flags - bitfield">
            <enum name="CL_MEM_READ_WRITE"/>
            <enum name="CL_MEM_WRITE_ONLY"/>
            <enum name="CL_MEM_READ_ONLY"/>
            <enum name="CL_MEM_USE_HOST_PTR"/>
            <enum name="CL_MEM_ALLOC_HOST_PTR"/>
            <enum name="CL_MEM_COPY_HOST_PTR"/>
        </require>
        <require comment="cl_profiling_info">
            <enum name="CL_PROFILING_COMMAND_QUEUED" return_type="cl_ulong"/>
            <enum name="CL_PROFILING_COMMAND_SUBMIT" return_type="cl_ulong"/>
            <enum name="CL_PROFILING_COMMAND_START" return_type="cl_ulong"/>
            <enum name="CL_PROFILING_COMMAND_END" return_type="cl_ulong"/>
        </require>
        <require comment="cl_channel_order">
            <enum name="CL_R"/>
            <enum name="CL_A"/>
            <enum name="CL_RG"/>
            <enum name="CL_RA"/>
            <enum name="CL_RGB"/>
            <enum name="CL_RGBA"/>
            <enum name="CL_BGRA"/>
            <enum name="CL_ARGB"/>
            <enum name="CL_INTENSITY"/>
            <enum name="CL_LUMINANCE"/>
        </require>
        <require comment="cl_channel_type">
            <enum name="CL_SNORM_INT8"/>
            <enum name="CL_SNORM_INT16"/>
            <enum name="CL_UNORM_INT8"/>
            <enum name="CL_UNORM_INT16"/>
            <enum name="CL_UNORM_SHORT_565"/>
            <enum name="CL_UNORM_SHORT_555"/>
            <enum name="CL_UNORM_INT_101010"/>
            <enum name="CL_SIGNED_INT8"/>
            <enum name="CL_SIGNED_INT16"/>
            <enum name="CL_SIGNED_INT32"/>
            <enum name="CL_UNSIGNED_INT8"/>
            <enum name="CL_UNSIGNED_INT16"/>
            <enum name="CL_UNSIGNED_INT32"/>
            <enum name="CL_HALF_FLOAT"/>
            <enum name="CL_FLOAT"/>
        </require>
        <require comment="cl_mem_object_type">
            <enum name="CL_MEM_OBJECT_BUFFER"/>
            <enum name="CL_MEM_OBJECT_IMAGE2D"/>
            <enum name="CL_MEM_OBJECT_IMAGE3D"/>
        </require>
        <require comment="cl_mem_info">
            <enum name="CL_MEM_TYPE" return_type="cl_mem_object_type"/>
            <enum name="CL_MEM_FLAGS" return_type="cl_mem_flags"/>
            <enum name="CL_MEM_SIZE" return_type="size_t"/>
            <enum name="CL_MEM_HOST_PTR" return_type="void*"/>
            <enum name="CL_MEM_MAP_COUNT" return_type="cl_uint"/>
            <enum name="CL_MEM_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_MEM_CONTEXT" return_type="cl_context"/>
        </require>
        <require comment="cl_image_info">
            <enum name="CL_IMAGE_FORMAT" return_type="cl_image_format"/>
            <enum name="CL_IMAGE_ELEMENT_SIZE" return_type="size_t"/>
            <enum name="CL_IMAGE_ROW_PITCH" return_type="size_t"/>
            <enum name="CL_IMAGE_SLICE_PITCH" return_type="size_t"/>
            <enum name="CL_IMAGE_WIDTH" return_type="size_t"/>
            <enum name="CL_IMAGE_HEIGHT" return_type="size_t"/>
            <enum name="CL_IMAGE_DEPTH" return_type="size_t"/>
        </require>
        <require comment="cl_addressing_mode">
            <enum name="CL_ADDRESS_NONE"/>
            <enum name="CL_ADDRESS_CLAMP_TO_EDGE"/>
            <enum name="CL_ADDRESS_CLAMP"/>
            <enum name="CL_ADDRESS_REPEAT"/>
        </require>
        <require comment="cl_filter_mode">
            <enum name="CL_FILTER_NEAREST"/>
            <enum name="CL_FILTER_LINEAR"/>
        </require>
        <require comment="cl_sampler_info">
            <enum name="CL_SAMPLER_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_SAMPLER_CONTEXT" return_type="cl_context"/>
            <enum name="CL_SAMPLER_NORMALIZED_COORDS" return_type="cl_bool"/>
            <enum name="CL_SAMPLER_ADDRESSING_MODE" return_type="cl_addressing_mode"/>
            <enum name="CL_SAMPLER_FILTER_MODE" return_type="cl_filter_mode"/>
        </require>
        <require comment="cl_map_flags - bitfield">
            <enum name="CL_MAP_READ"/>
            <enum name="CL_MAP_WRITE"/>
        </require>
        <require comment="cl_program_info">
            <enum name="CL_PROGRAM_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_PROGRAM_CONTEXT" return_type="cl_context"/>
            <enum name="CL_PROGRAM_NUM_DEVICES" return_type="cl_uint"/>
            <enum name="CL_PROGRAM_DEVICES" return_type="cl_device_id[]"/>
            <enum name="CL_PROGRAM_SOURCE" return_type="char[]"/>
            <enum name="CL_PROGRAM_BINARY_SIZES" return_type="size_t[]"/>
            <enum name="CL_PROGRAM_BINARIES" return_type="unsigned char*[]"/>
        </require>
        <require comment="cl_program_build_info">
            <enum name="CL_PROGRAM_BUILD_STATUS" return_type="cl_build_status"/>
            <enum name="CL_PROGRAM_BUILD_OPTIONS" return_type="char[]"/>
            <enum name="CL_PROGRAM_BUILD_LOG" return_type="char[]"/>
        </require>
        <require comment="cl_build_status">
            <enum name="CL_BUILD_SUCCESS"/>
            <enum name="CL_BUILD_NONE"/>
            <enum name="CL_BUILD_ERROR"/>
            <enum name="CL_BUILD_IN_PROGRESS"/>
        </require>
        <require comment="cl_kernel_info">
            <enum name="CL_KERNEL_FUNCTION_NAME" return_type="char[]"/>
            <enum name="CL_KERNEL_NUM_ARGS" return_type="cl_uint"/>
            <enum name="CL_KERNEL_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_KERNEL_CONTEXT" return_type="cl_context"/>
            <enum name="CL_KERNEL_PROGRAM" return_type="cl_program"/>
        </require>
        <require comment="cl_kernel_work_group_info">
            <enum name="CL_KERNEL_WORK_GROUP_SIZE" return_type="size_t"/>
            <enum name="CL_KERNEL_COMPILE_WORK_GROUP_SIZE" return_type="size_t[3]"/>
            <enum name="CL_KERNEL_LOCAL_MEM_SIZE" return_type="cl_ulong"/>
            <enum name="CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE" return_type="size_t"/>
            <enum name="CL_KERNEL_PRIVATE_MEM_SIZE" return_type="cl_ulong"/>
        </require>
        <require comment="cl_event_info">
            <enum name="CL_EVENT_COMMAND_QUEUE" return_type="cl_command_queue"/>
            <enum name="CL_EVENT_COMMAND_TYPE" return_type="cl_command_type"/>
            <enum name="CL_EVENT_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_EVENT_COMMAND_EXECUTION_STATUS" return_type="cl_int"/>
        </require>
        <require comment="cl_command_type">
            <enum name="CL_COMMAND_NDRANGE_KERNEL"/>
            <enum name="CL_COMMAND_TASK"/>
            <enum name="CL_COMMAND_NATIVE_KERNEL"/>
            <enum name="CL_COMMAND_READ_BUFFER"/>
            <enum name="CL_COMMAND_WRITE_BUFFER"/>
            <enum name="CL_COMMAND_COPY_BUFFER"/>
            <enum name="CL_COMMAND_READ_IMAGE"/>
            <enum name="CL_COMMAND_WRITE_IMAGE"/>
            <enum name="CL_COMMAND_COPY_IMAGE"/>
            <enum name="CL_COMMAND_COPY_IMAGE_TO_BUFFER"/>
            <enum name="CL_COMMAND_COPY_BUFFER_TO_IMAGE"/>
            <enum name="CL_COMMAND_MAP_BUFFER"/>
            <enum name="CL_COMMAND_MAP_IMAGE"/>
            <enum name="CL_COMMAND_UNMAP_MEM_OBJECT"/>
            <enum name="CL_COMMAND_MARKER"/>
            <enum name="CL_COMMAND_ACQUIRE_GL_OBJECTS"/>
            <enum name="CL_COMMAND_RELEASE_GL_OBJECTS"/>
        </require>
        <require comment="command execution status">
            <enum name="CL_COMPLETE"/>
            <enum name="CL_RUNNING"/>
            <enum name="CL_SUBMITTED"/>
            <enum name="CL_QUEUED"/>
        </require>
        <require comment="cl_khronos_vendor_id">
            <!-- The cl_khronos_vendor_id type was added in OpenCL 3.0, but the
                 concept of assigned vendor IDs has existed since OpenCL 1.0.
                 These enums can be used in any OpenCL version because the type
                 used in the API is cl_uint. -->
            <enum name="CL_KHRONOS_VENDOR_ID_CODEPLAY"/>
            <enum name="CL_KHRONOS_VENDOR_ID_POCL"/>
        </require>
        <require comment="Platform APIs">
            <command name="clGetPlatformIDs"/>
            <command name="clGetPlatformInfo"/>
        </require>
        <require comment="Device APIs">
            <command name="clGetDeviceIDs"/>
            <command name="clGetDeviceInfo"/>
        </require>
        <require comment="Context APIs">
            <command name="clCreateContext"/>
            <command name="clCreateContextFromType"/>
            <command name="clRetainContext"/>
            <command name="clReleaseContext"/>
            <command name="clGetContextInfo"/>
        </require>
        <require comment="Command Queue APIs">
            <command name="clRetainCommandQueue"/>
            <command name="clReleaseCommandQueue"/>
            <command name="clGetCommandQueueInfo"/>
        </require>
        <require comment="Memory Object APIs">
            <command name="clCreateBuffer"/>
            <command name="clRetainMemObject"/>
            <command name="clReleaseMemObject"/>
            <command name="clGetSupportedImageFormats"/>
            <command name="clGetMemObjectInfo"/>
            <command name="clGetImageInfo"/>
        </require>
        <require comment="Sampler APIs">
            <command name="clRetainSampler"/>
            <command name="clReleaseSampler"/>
            <command name="clGetSamplerInfo"/>
        </require>
        <require comment="Program Object APIs">
            <command name="clCreateProgramWithSource"/>
            <command name="clCreateProgramWithBinary"/>
            <command name="clRetainProgram"/>
            <command name="clReleaseProgram"/>
            <command name="clBuildProgram"/>
            <command name="clGetProgramInfo"/>
            <command name="clGetProgramBuildInfo"/>
        </require>
        <require comment="Kernel Object APIs">
            <command name="clCreateKernel"/>
            <command name="clCreateKernelsInProgram"/>
            <command name="clRetainKernel"/>
            <command name="clReleaseKernel"/>
            <command name="clSetKernelArg"/>
            <command name="clGetKernelInfo"/>
            <command name="clGetKernelWorkGroupInfo"/>
        </require>
        <require comment="Event Object APIs">
            <command name="clWaitForEvents"/>
            <command name="clGetEventInfo"/>
            <command name="clRetainEvent"/>
            <command name="clReleaseEvent"/>
        </require>
        <require comment="Profiling APIs">
            <command name="clGetEventProfilingInfo"/>
        </require>
        <require comment="Flush and Finish APIs">
            <command name="clFlush"/>
            <command name="clFinish"/>
        </require>
        <require comment="Enqueued Commands APIs">
            <command name="clEnqueueReadBuffer"/>
            <command name="clEnqueueWriteBuffer"/>
            <command name="clEnqueueCopyBuffer"/>
            <command name="clEnqueueReadImage"/>
            <command name="clEnqueueWriteImage"/>
            <command name="clEnqueueCopyImage"/>
            <command name="clEnqueueCopyImageToBuffer"/>
            <command name="clEnqueueCopyBufferToImage"/>
            <command name="clEnqueueMapBuffer"/>
            <command name="clEnqueueMapImage"/>
            <command name="clEnqueueUnmapMemObject"/>
            <command name="clEnqueueNDRangeKernel"/>
            <command name="clEnqueueNativeKernel"/>
        </require>
        <require comment="OpenCL 1.0 APIs that were deprecated in OpenCL 1.1">
            <comment>
            #ifdef CL_USE_DEPRECATED_OPENCL_1_0_APIS
                /*
                 *  WARNING:
                 *     This API introduces mutable state into the OpenCL implementation. It has been REMOVED
                 *  to better facilitate thread safety.  The 1.0 API is not thread safe. It is not tested by the
                 *  OpenCL 1.1 conformance test, and consequently may not work or may not work dependably.
                 *  It is likely to be non-performant. Use of this API is not advised. Use at your own risk.
                 *
                 *  Software developers previously relying on this API are instructed to set the command queue
                 *  properties when creating the queue, instead.
                 */
            #endif /* CL_USE_DEPRECATED_OPENCL_1_0_APIS */
            </comment>
            <command name="clSetCommandQueueProperty"/>
        </require>
        <require comment="OpenCL 1.0 APIs that were deprecated in OpenCL 1.2">
            <command name="clCreateImage2D"/>
            <command name="clCreateImage3D"/>
            <command name="clEnqueueMarker"/>
            <command name="clEnqueueWaitForEvents"/>
            <command name="clEnqueueBarrier"/>
            <command name="clUnloadCompiler"/>
            <command name="clGetExtensionFunctionAddress"/>
        </require>
        <require comment="OpenCL 1.0 cl_device_info enums that were deprecated in OpenCL 1.2">
            <enum name="CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE" return_type="cl_uint"/>
        </require>
        <require comment="OpenCL 1.0 APIs that were deprecated in OpenCL 2.0">
            <command name="clCreateCommandQueue"/>
            <command name="clCreateSampler"/>
            <command name="clEnqueueTask"/>
        </require>
        <require comment="OpenCL 1.0 cl_device_info enums that were deprecated in OpenCL 2.0">
            <enum name="CL_DEVICE_QUEUE_PROPERTIES" return_type="cl_command_queue_properties"/>
        </require>
    </feature>

    <feature api="opencl" name="CL_VERSION_1_1" number="1.1" comment="OpenCL core API interface definitions">
        <require>
            <type name="cl_buffer_create_type"/>
        </require>
        <require comment="Constants">
            <enum name="CL_NAN"/>
            <enum name="CL_HUGE_VALF"/>
            <enum name="CL_HUGE_VAL"/>
            <enum name="CL_MAXFLOAT"/>
            <enum name="CL_INFINITY"/>
        </require>
        <require comment="Error codes">
            <enum name="CL_MISALIGNED_SUB_BUFFER_OFFSET"/>
            <enum name="CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST"/>
            <enum name="CL_INVALID_PROPERTY"/>
        </require>
        <require comment="cl_device_info">
            <enum name="CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_INT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE" return_type="cl_uint"/>
            <enum name="CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF" return_type="cl_uint"/>
        </require>
        <require comment="cl_device_fp_config - bitfield">
            <enum name="CL_FP_SOFT_FLOAT"/>
        </require>
        <require comment="cl_context_info">
            <enum name="CL_CONTEXT_NUM_DEVICES" return_type="cl_uint"/>
        </require>
        <require comment="cl_channel_order">
            <enum name="CL_Rx"/>
            <enum name="CL_RGx"/>
            <enum name="CL_RGBx"/>
        </require>
        <require comment="cl_mem_info">
            <enum name="CL_MEM_ASSOCIATED_MEMOBJECT" return_type="cl_mem"/>
            <enum name="CL_MEM_OFFSET" return_type="size_t"/>
        </require>
        <require comment="cl_addressing_mode">
            <enum name="CL_ADDRESS_MIRRORED_REPEAT"/>
        </require>
        <require comment="cl_event_info">
            <enum name="CL_EVENT_CONTEXT" return_type="cl_context"/>
        </require>
        <require comment="cl_command_type">
            <enum name="CL_COMMAND_READ_BUFFER_RECT"/>
            <enum name="CL_COMMAND_WRITE_BUFFER_RECT"/>
            <enum name="CL_COMMAND_COPY_BUFFER_RECT"/>
            <enum name="CL_COMMAND_USER"/>
        </require>
        <require comment="cl_buffer_create_type">
            <enum name="CL_BUFFER_CREATE_TYPE_REGION" return_type="cl_buffer_region"/>
        </require>
        <require comment="Memory Object APIs">
            <command name="clCreateSubBuffer"/>
            <command name="clSetMemObjectDestructorCallback"/>
        </require>
        <require comment="Event Object APIs">
            <command name="clCreateUserEvent"/>
            <command name="clSetUserEventStatus"/>
            <command name="clSetEventCallback"/>
        </require>
        <require comment="Enqueued Commands APIs">
            <command name="clEnqueueReadBufferRect"/>
            <command name="clEnqueueWriteBufferRect"/>
            <command name="clEnqueueCopyBufferRect"/>
        </require>
        <require comment="OpenCL 1.1 cl_device_info enums that were deprecated in OpenCL 2.0">
            <enum name="CL_DEVICE_HOST_UNIFIED_MEMORY" return_type="cl_bool"/>
        </require>
        <require comment="OpenCL 1.1 cl_device_info enums that were deprecated in OpenCL 3.0">
            <enum name="CL_DEVICE_OPENCL_C_VERSION" return_type="char[]"/>
        </require>
    </feature>

    <feature api="opencl" name="CL_VERSION_1_2" number="1.2" comment="OpenCL core API interface definitions">
        <require>
            <type name="cl_device_partition_property"/>
            <type name="cl_device_affinity_domain"/>
            <type name="cl_mem_migration_flags"/>
            <type name="cl_program_binary_type"/>
            <type name="cl_kernel_arg_info"/>
            <type name="cl_kernel_arg_address_qualifier"/>
            <type name="cl_kernel_arg_access_qualifier"/>
            <type name="cl_kernel_arg_type_qualifier"/>
            <type name="cl_image_desc"/>
        </require>
        <require comment="Constants">
            <enum name="CL_DBL_DIG"/>
            <enum name="CL_DBL_MANT_DIG"/>
            <enum name="CL_DBL_MAX_10_EXP"/>
            <enum name="CL_DBL_MAX_EXP"/>
            <enum name="CL_DBL_MIN_10_EXP"/>
            <enum name="CL_DBL_MIN_EXP"/>
            <enum name="CL_DBL_RADIX"/>
            <enum name="CL_DBL_MAX"/>
            <enum name="CL_DBL_MIN"/>
            <enum name="CL_DBL_EPSILON"/>
        </require>
        <require comment="Error codes">
            <enum name="CL_COMPILE_PROGRAM_FAILURE"/>
            <enum name="CL_LINKER_NOT_AVAILABLE"/>
            <enum name="CL_LINK_PROGRAM_FAILURE"/>
            <enum name="CL_DEVICE_PARTITION_FAILED"/>
            <enum name="CL_KERNEL_ARG_INFO_NOT_AVAILABLE"/>
            <enum name="CL_INVALID_IMAGE_DESCRIPTOR"/>
            <enum name="CL_INVALID_COMPILER_OPTIONS"/>
            <enum name="CL_INVALID_LINKER_OPTIONS"/>
            <enum name="CL_INVALID_DEVICE_PARTITION_COUNT"/>
        </require>
        <require comment="cl_command_type">
            <enum name="CL_COMMAND_BARRIER"/>
            <enum name="CL_COMMAND_MIGRATE_MEM_OBJECTS"/>
            <enum name="CL_COMMAND_FILL_BUFFER"/>
            <enum name="CL_COMMAND_FILL_IMAGE"/>
        </require>
        <require comment="cl_bool">
            <enum name="CL_BLOCKING"/>
            <enum name="CL_NON_BLOCKING"/>
        </require>
        <require comment="cl_device_type - bitfield">
            <enum name="CL_DEVICE_TYPE_CUSTOM"/>
        </require>
        <require comment="cl_device_info">
            <enum name="CL_DEVICE_DOUBLE_FP_CONFIG" return_type="cl_device_fp_config"/>
            <enum name="CL_DEVICE_LINKER_AVAILABLE" return_type="cl_bool"/>
            <enum name="CL_DEVICE_BUILT_IN_KERNELS" return_type="char[]"/>
            <enum name="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE" return_type="size_t"/>
            <enum name="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE" return_type="size_t"/>
            <enum name="CL_DEVICE_PARENT_DEVICE" return_type="cl_device_id"/>
            <enum name="CL_DEVICE_PARTITION_MAX_SUB_DEVICES" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PARTITION_PROPERTIES" return_type="cl_device_partition_property[]"/>
            <enum name="CL_DEVICE_PARTITION_AFFINITY_DOMAIN" return_type="cl_device_affinity_domain"/>
            <enum name="CL_DEVICE_PARTITION_TYPE" return_type="cl_device_partition_property[]"/>
            <enum name="CL_DEVICE_REFERENCE_COUNT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_INTEROP_USER_SYNC" return_type="cl_bool"/>
            <enum name="CL_DEVICE_PRINTF_BUFFER_SIZE" return_type="size_t"/>
        </require>
        <require comment="cl_device_fp_config - bitfield">
            <enum name="CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT"/>
        </require>
        <require comment="cl_context_properties">
            <enum name="CL_CONTEXT_INTEROP_USER_SYNC"/>
        </require>
        <require comment="cl_device_partition_property">
            <enum name="CL_DEVICE_PARTITION_EQUALLY"/>
            <enum name="CL_DEVICE_PARTITION_BY_COUNTS"/>
            <enum name="CL_DEVICE_PARTITION_BY_COUNTS_LIST_END"/>
            <enum name="CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN"/>
        </require>
        <require comment="cl_device_affinity_domain">
            <enum name="CL_DEVICE_AFFINITY_DOMAIN_NUMA"/>
            <enum name="CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE"/>
            <enum name="CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE"/>
            <enum name="CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE"/>
            <enum name="CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE"/>
            <enum name="CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE"/>
        </require>
        <require comment="cl_mem_flags and cl_svm_mem_flags - bitfield">
            <enum name="CL_MEM_HOST_WRITE_ONLY"/>
            <enum name="CL_MEM_HOST_READ_ONLY"/>
            <enum name="CL_MEM_HOST_NO_ACCESS"/>
        </require>
        <require comment="cl_mem_migration_flags - bitfield">
            <enum name="CL_MIGRATE_MEM_OBJECT_HOST"/>
            <enum name="CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED"/>
        </require>
        <require comment="cl_mem_object_type">
            <enum name="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
            <enum name="CL_MEM_OBJECT_IMAGE1D"/>
            <enum name="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
            <enum name="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
        </require>
        <require comment="cl_image_info">
            <enum name="CL_IMAGE_ARRAY_SIZE" return_type="size_t"/>
            <enum name="CL_IMAGE_NUM_MIP_LEVELS" return_type="cl_uint"/>
            <enum name="CL_IMAGE_NUM_SAMPLES" return_type="cl_uint"/>
        </require>
        <require comment="cl_map_flags - bitfield">
            <enum name="CL_MAP_WRITE_INVALIDATE_REGION"/>
        </require>
        <require comment="cl_program_info">
            <enum name="CL_PROGRAM_NUM_KERNELS" return_type="size_t"/>
            <enum name="CL_PROGRAM_KERNEL_NAMES" return_type="char[]"/>
        </require>
        <require comment="cl_program_build_info">
            <enum name="CL_PROGRAM_BINARY_TYPE" return_type="cl_program_binary_type"/>
        </require>
        <require comment="cl_program_binary_type">
            <enum name="CL_PROGRAM_BINARY_TYPE_NONE"/>
            <enum name="CL_PROGRAM_BINARY_TYPE_COMPILED_OBJECT"/>
            <enum name="CL_PROGRAM_BINARY_TYPE_LIBRARY"/>
            <enum name="CL_PROGRAM_BINARY_TYPE_EXECUTABLE"/>
        </require>
        <require comment="cl_kernel_info">
            <enum name="CL_KERNEL_ATTRIBUTES" return_type="char[]"/>
        </require>
        <require comment="cl_kernel_arg_info">
            <enum name="CL_KERNEL_ARG_ADDRESS_QUALIFIER" return_type="cl_kernel_arg_address_qualifier"/>
            <enum name="CL_KERNEL_ARG_ACCESS_QUALIFIER" return_type="cl_kernel_arg_access_qualifier"/>
            <enum name="CL_KERNEL_ARG_TYPE_NAME" return_type="char[]"/>
            <enum name="CL_KERNEL_ARG_TYPE_QUALIFIER" return_type="cl_kernel_arg_type_qualifier"/>
            <enum name="CL_KERNEL_ARG_NAME" return_type="char[]"/>
        </require>
        <require comment="cl_kernel_arg_address_qualifier">
            <enum name="CL_KERNEL_ARG_ADDRESS_GLOBAL"/>
            <enum name="CL_KERNEL_ARG_ADDRESS_LOCAL"/>
            <enum name="CL_KERNEL_ARG_ADDRESS_CONSTANT"/>
            <enum name="CL_KERNEL_ARG_ADDRESS_PRIVATE"/>
        </require>
        <require comment="cl_kernel_arg_access_qualifier">
            <enum name="CL_KERNEL_ARG_ACCESS_READ_ONLY"/>
            <enum name="CL_KERNEL_ARG_ACCESS_WRITE_ONLY"/>
            <enum name="CL_KERNEL_ARG_ACCESS_READ_WRITE"/>
            <enum name="CL_KERNEL_ARG_ACCESS_NONE"/>
        </require>
        <require comment="cl_kernel_arg_type_qualifier">
            <enum name="CL_KERNEL_ARG_TYPE_NONE"/>
            <enum name="CL_KERNEL_ARG_TYPE_CONST"/>
            <enum name="CL_KERNEL_ARG_TYPE_RESTRICT"/>
            <enum name="CL_KERNEL_ARG_TYPE_VOLATILE"/>
        </require>
        <require comment="cl_kernel_work_group_info">
            <enum name="CL_KERNEL_GLOBAL_WORK_SIZE" return_type="size_t[3]"/>
        </require>
        <require comment="Platform APIs">
            <command name="clCreateSubDevices"/>
            <command name="clRetainDevice"/>
            <command name="clReleaseDevice"/>
        </require>
        <require comment="Memory Object APIs">
            <command name="clCreateImage"/>
        </require>
        <require comment="Program Object APIs">
            <command name="clCreateProgramWithBuiltInKernels"/>
            <command name="clCompileProgram"/>
            <command name="clLinkProgram"/>
            <command name="clUnloadPlatformCompiler"/>
        </require>
        <require comment="Kernel Object APIs">
            <command name="clGetKernelArgInfo"/>
        </require>
        <require comment="Enqueued Commands APIs">
            <command name="clEnqueueFillBuffer"/>
            <command name="clEnqueueFillImage"/>
            <command name="clEnqueueMigrateMemObjects"/>
            <command name="clEnqueueMarkerWithWaitList"/>
            <command name="clEnqueueBarrierWithWaitList"/>
        </require>
        <require comment="Extension function access">
            <command name="clGetExtensionFunctionAddressForPlatform"/>
        </require>
        <require comment="OpenCL 1.2 cl_image_info enums that were deprecated in OpenCL 2.0">
            <enum name="CL_IMAGE_BUFFER" return_type="cl_mem"/>
        </require>
    </feature>

    <feature api="opencl" name="CL_VERSION_2_0" number="2.0" comment="OpenCL core API interface definitions">
        <require>
            <type name="cl_device_svm_capabilities"/>
            <type name="cl_queue_properties"/>
            <type name="cl_svm_mem_flags"/>
            <type name="cl_pipe_properties"/>
            <type name="cl_pipe_info"/>
            <type name="cl_sampler_properties"/>
            <type name="cl_kernel_exec_info"/>
        </require>
        <require comment="Error codes">
            <enum name="CL_INVALID_PIPE_SIZE"/>
            <enum name="CL_INVALID_DEVICE_QUEUE"/>
        </require>
        <require comment="cl_device_info">
            <enum name="CL_DEVICE_QUEUE_ON_HOST_PROPERTIES" return_type="cl_command_queue_properties"/>
            <enum name="CL_DEVICE_IMAGE_PITCH_ALIGNMENT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_READ_WRITE_IMAGE_ARGS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_GLOBAL_VARIABLE_SIZE" return_type="size_t"/>
            <enum name="CL_DEVICE_QUEUE_ON_DEVICE_PROPERTIES" return_type="cl_command_queue_properties"/>
            <enum name="CL_DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE" return_type="cl_uint"/>
            <enum name="CL_DEVICE_QUEUE_ON_DEVICE_MAX_SIZE" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_ON_DEVICE_QUEUES" return_type="cl_uint"/>
            <enum name="CL_DEVICE_MAX_ON_DEVICE_EVENTS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_SVM_CAPABILITIES" return_type="cl_device_svm_capabilities"/>
            <enum name="CL_DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE" return_type="size_t"/>
            <enum name="CL_DEVICE_MAX_PIPE_ARGS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PIPE_MAX_PACKET_SIZE" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT" return_type="cl_uint"/>
            <enum name="CL_DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT" return_type="cl_uint"/>
        </require>
        <require comment="cl_command_queue_properties - bitfield">
            <enum name="CL_QUEUE_ON_DEVICE"/>
            <enum name="CL_QUEUE_ON_DEVICE_DEFAULT"/>
        </require>
        <require comment="cl_device_svm_capabilities">
            <enum name="CL_DEVICE_SVM_COARSE_GRAIN_BUFFER"/>
            <enum name="CL_DEVICE_SVM_FINE_GRAIN_BUFFER"/>
            <enum name="CL_DEVICE_SVM_FINE_GRAIN_SYSTEM"/>
            <enum name="CL_DEVICE_SVM_ATOMICS"/>
        </require>
        <require comment="cl_command_queue_info">
            <enum name="CL_QUEUE_SIZE" return_type="cl_uint"/>
        </require>
        <require comment="cl_mem_flags and cl_svm_mem_flags - bitfield">
            <enum name="CL_MEM_SVM_FINE_GRAIN_BUFFER"/>
            <enum name="CL_MEM_SVM_ATOMICS"/>
            <enum name="CL_MEM_KERNEL_READ_AND_WRITE"/>
        </require>
        <require comment="cl_channel_order">
            <enum name="CL_DEPTH"/>
            <enum name="CL_sRGB"/>
            <enum name="CL_sRGBx"/>
            <enum name="CL_sRGBA"/>
            <enum name="CL_sBGRA"/>
            <enum name="CL_ABGR"/>
        </require>
        <require comment="cl_mem_object_type">
            <enum name="CL_MEM_OBJECT_PIPE"/>
        </require>
        <require comment="cl_mem_info">
            <enum name="CL_MEM_USES_SVM_POINTER" return_type="cl_bool"/>
        </require>
        <require comment="cl_pipe_info">
            <enum name="CL_PIPE_PACKET_SIZE" return_type="cl_uint"/>
            <enum name="CL_PIPE_MAX_PACKETS" return_type="cl_uint"/>
        </require>
        <!--<require comment="cl_sampler_info">
            <enum name="CL_SAMPLER_MIP_FILTER_MODE"/>
            <enum name="CL_SAMPLER_LOD_MIN"/>
            <enum name="CL_SAMPLER_LOD_MAX"/>
        </require>-->
        <require comment="cl_program_build_info">
            <enum name="CL_PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE" return_type="size_t"/>
        </require>
        <require comment="cl_kernel_arg_type_qualifier">
            <enum name="CL_KERNEL_ARG_TYPE_PIPE"/>
        </require>
        <require comment="cl_kernel_exec_info">
            <enum name="CL_KERNEL_EXEC_INFO_SVM_PTRS" return_type="void*[]"/>
            <enum name="CL_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM" return_type="cl_bool"/>
        </require>
        <require comment="cl_command_type">
            <enum name="CL_COMMAND_SVM_FREE"/>
            <enum name="CL_COMMAND_SVM_MEMCPY"/>
            <enum name="CL_COMMAND_SVM_MEMFILL"/>
            <enum name="CL_COMMAND_SVM_MAP"/>
            <enum name="CL_COMMAND_SVM_UNMAP"/>
        </require>
        <require comment="cl_profiling_info">
            <enum name="CL_PROFILING_COMMAND_COMPLETE" return_type="cl_ulong"/>
        </require>
        <require comment="Command Queue APIs">
            <command name="clCreateCommandQueueWithProperties"/>
        </require>
        <require comment="Pipe APIs">
            <command name="clCreatePipe"/>
            <command name="clGetPipeInfo"/>
        </require>
        <require comment="SVM Allocation APIs">
            <command name="clSVMAlloc"/>
            <command name="clSVMFree"/>
        </require>
        <require comment="Sampler APIs">
            <command name="clCreateSamplerWithProperties"/>
        </require>
        <require comment="Kernel Object APIs">
            <command name="clSetKernelArgSVMPointer"/>
            <command name="clSetKernelExecInfo"/>
        </require>
        <require comment="Enqueued Commands APIs">
            <command name="clEnqueueSVMFree"/>
            <command name="clEnqueueSVMMemcpy"/>
            <command name="clEnqueueSVMMemFill"/>
            <command name="clEnqueueSVMMap"/>
            <command name="clEnqueueSVMUnmap"/>
        </require>
    </feature>

    <feature api="opencl" name="CL_VERSION_2_1" number="2.1" comment="OpenCL core API interface definitions">
        <require>
            <type name="cl_kernel_sub_group_info"/>
        </require>
        <require comment="cl_platform_info">
            <enum name="CL_PLATFORM_HOST_TIMER_RESOLUTION" return_type="cl_ulong"/>
        </require>
        <require comment="cl_device_info">
            <enum name="CL_DEVICE_IL_VERSION" return_type="char[]"/>
            <enum name="CL_DEVICE_MAX_NUM_SUB_GROUPS" return_type="cl_uint"/>
            <enum name="CL_DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS" return_type="cl_bool"/>
        </require>
        <require comment="cl_command_queue_info">
            <enum name="CL_QUEUE_DEVICE_DEFAULT" return_type="cl_command_queue"/>
        </require>
        <require comment="cl_channel_type">
            <enum name="CL_UNORM_INT_101010_2"/>
        </require>
        <require comment="cl_program_info">
            <enum name="CL_PROGRAM_IL" return_type="char[]"/>
        </require>
        <require comment="cl_kernel_sub_group_info">
            <enum name="CL_KERNEL_MAX_NUM_SUB_GROUPS" return_type="size_t"/>
            <enum name="CL_KERNEL_COMPILE_NUM_SUB_GROUPS" return_type="size_t"/>
            <enum name="CL_KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE" return_type="size_t"/>
            <enum name="CL_KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE" return_type="size_t"/>
            <enum name="CL_KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT" return_type="size_t[]"/>
        </require>
        <require comment="Platform APIs">
            <command name="clSetDefaultDeviceCommandQueue"/>
        </require>
        <require comment="Device APIs">
            <command name="clGetDeviceAndHostTimer"/>
            <command name="clGetHostTimer"/>
        </require>
        <require comment="Program Object APIs">
            <command name="clCreateProgramWithIL"/>
        </require>
        <require comment="Kernel Object APIs">
            <command name="clCloneKernel"/>
            <command name="clGetKernelSubGroupInfo"/>
        </require>
        <require comment="Enqueued Commands APIs">
            <command name="clEnqueueSVMMigrateMem"/>
        </require>
    </feature>

    <feature api="opencl" name="CL_VERSION_2_2" number="2.2" comment="OpenCL core API interface definitions">
        <require comment="Error codes">
            <enum name="CL_INVALID_SPEC_ID"/>
            <enum name="CL_MAX_SIZE_RESTRICTION_EXCEEDED"/>
        </require>
        <require comment="Program Object APIs">
            <command name="clSetProgramSpecializationConstant"/>
        </require>
        <require comment="OpenCL 2.2 Program Object APIs that were deprecated in OpenCL 3.0">
            <command name="clSetProgramReleaseCallback"/>
        </require>
        <require comment="OpenCL 2.2 cl_program_info enums that were deprecated in OpenCL 3.0">
            <enum name="CL_PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT" return_type="cl_bool"/>
            <enum name="CL_PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT" return_type="cl_bool"/>
        </require>
    </feature>

    <feature api="opencl" name="CL_VERSION_3_0" number="3.0" comment="OpenCL core API interface definitions">
        <require>
            <type name="cl_device_atomic_capabilities"/>
            <type name="cl_device_device_enqueue_capabilities"/>
            <type name="cl_khronos_vendor_id"/>
            <type name="cl_mem_properties"/>
            <type name="cl_version"/>
            <type name="cl_name_version"/>
        </require>
        <require comment="cl_device_atomic_capabilities - bitfield">
            <enum name="CL_DEVICE_ATOMIC_ORDER_RELAXED"/>
            <enum name="CL_DEVICE_ATOMIC_ORDER_ACQ_REL"/>
            <enum name="CL_DEVICE_ATOMIC_ORDER_SEQ_CST"/>
            <enum name="CL_DEVICE_ATOMIC_SCOPE_WORK_ITEM"/>
            <enum name="CL_DEVICE_ATOMIC_SCOPE_WORK_GROUP"/>
            <enum name="CL_DEVICE_ATOMIC_SCOPE_DEVICE"/>
            <enum name="CL_DEVICE_ATOMIC_SCOPE_ALL_DEVICES"/>
        </require>
        <require comment="cl_device_device_enqueue_capabilities - bitfield">
            <enum name="CL_DEVICE_QUEUE_SUPPORTED"/>
            <enum name="CL_DEVICE_QUEUE_REPLACEABLE_DEFAULT"/>
        </require>
        <require comment="cl_platform_info">
            <enum name="CL_PLATFORM_NUMERIC_VERSION" return_type="cl_version"/>
            <enum name="CL_PLATFORM_EXTENSIONS_WITH_VERSION" return_type="cl_name_version[]"/>
        </require>
        <require comment="cl_device_info">
            <enum name="CL_DEVICE_ATOMIC_MEMORY_CAPABILITIES" return_type="cl_device_atomic_capabilities"/>
            <enum name="CL_DEVICE_ATOMIC_FENCE_CAPABILITIES" return_type="cl_device_atomic_capabilities"/>
            <enum name="CL_DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT" return_type="cl_bool"/>
            <enum name="CL_DEVICE_OPENCL_C_ALL_VERSIONS" return_type="cl_name_version[]"/>
            <enum name="CL_DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT" return_type="cl_bool"/>
            <enum name="CL_DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT" return_type="cl_bool"/>
            <enum name="CL_DEVICE_OPENCL_C_FEATURES" return_type="cl_name_version[]"/>
            <enum name="CL_DEVICE_DEVICE_ENQUEUE_CAPABILITIES" return_type="cl_device_device_enqueue_capabilities"/>
            <enum name="CL_DEVICE_PIPE_SUPPORT" return_type="cl_bool"/>
            <enum name="CL_DEVICE_NUMERIC_VERSION" return_type="cl_version"/>
            <enum name="CL_DEVICE_EXTENSIONS_WITH_VERSION" return_type="cl_name_version[]"/>
            <enum name="CL_DEVICE_ILS_WITH_VERSION" return_type="cl_name_version[]"/>
            <enum name="CL_DEVICE_BUILT_IN_KERNELS_WITH_VERSION" return_type="cl_name_version[]"/>
            <enum name="CL_DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE" return_type="size_t"/>
            <enum name="CL_DEVICE_LATEST_CONFORMANCE_VERSION_PASSED" return_type="char[]"/>
        </require>
        <require comment="cl_pipe_info">
            <enum name="CL_PIPE_PROPERTIES" return_type="cl_pipe_properties[]"/>
        </require>
        <require comment="cl_sampler_info">
            <enum name="CL_SAMPLER_PROPERTIES" return_type="cl_sampler_properties[]"/>
        </require>
        <require comment="cl_command_queue_info">
            <enum name="CL_QUEUE_PROPERTIES_ARRAY" return_type="cl_queue_properties[]"/>
        </require>
        <require comment="cl_mem_info">
            <enum name="CL_MEM_PROPERTIES" return_type="cl_mem_properties[]"/>
        </require>
        <require comment="cl_command_type">
            <enum name="CL_COMMAND_SVM_MIGRATE_MEM"/>
        </require>
        <require comment="Misc API enums">
            <enum name="CL_VERSION_MAJOR_BITS"/>
            <enum name="CL_VERSION_MINOR_BITS"/>
            <enum name="CL_VERSION_PATCH_BITS"/>
            <enum name="CL_NAME_VERSION_MAX_NAME_SIZE"/>
        </require>
        <require comment="Context APIs">
            <command name="clSetContextDestructorCallback"/>
        </require>
        <require comment="Memory Object APIs">
            <command name="clCreateBufferWithProperties"/>
            <command name="clCreateImageWithProperties"/>
        </require>
    </feature>

    <!-- SECTION: CL command definitions. (TBD) -->
    <commands>
    <!-- 4.1 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetPlatformIDs</name></proto>
            <param><type>cl_uint</type>                                 <name>num_entries</name></param>
            <param><type>cl_platform_id</type>*                         <name>platforms</name></param>
            <param><type>cl_uint</type>*                                <name>num_platforms</name></param>

            <if>
                <and>
                    <eq>
                        <name>num_entries</name>                        <literal>0</literal>
                    </eq>
                    <neq>
                        <name>platforms</name>                          <literal>NULL</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>num_entries is equal to zero and platforms is not NULL</log>
                <name>clGetPlatformIDs</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>num_platforms</name>                      <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>platforms</name>                          <literal>NULL</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>both num_platforms and platforms are NULL</log>
                <name>clGetPlatformIDs</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>num_platforms</name>                          <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>platforms</name>                          <name>num_platforms[0]</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>platforms is too short</log>
                <name>clGetPlatformIDs</name>                           <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetPlatformInfo</name></proto>
            <param><type>cl_platform_id</type>                          <name>platform</name></param>
            <param><type>cl_platform_info</type>                        <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="platform"/>
            </if>
            <then>      <log>platform is not a valid platform</log>
                <name>clGetPlatformInfo</name>                          <value>CL_INVALID_PLATFORM</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetPlatformInfo</name>                          <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetPlatformInfo</name>                          <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetPlatformInfo</name>                          <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 4.2 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetDeviceIDs</name></proto>
            <param><type>cl_platform_id</type>                          <name>platform</name></param>
            <param><type>cl_device_type</type>                          <name>device_type</name></param>
            <param><type>cl_uint</type>                                 <name>num_entries</name></param>
            <param><type>cl_device_id</type>*                           <name>devices</name></param>
            <param><type>cl_uint</type>*                                <name>num_devices</name></param>

            <if>
                <object_is_invalid name="platform"/>
            </if>
            <then>      <log>platform is not a valid platform</log>
                <name>clGetDeviceIDs</name>                             <value>CL_INVALID_PLATFORM</value>
            </then>
            <if>
                <or>
                    <bitfield_violation name="device_type"/>
                    <eq>
                        <name>device_type</name>                        <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>device_type is not a valid value</log>
                <name>clGetDeviceIDs</name>                             <value>CL_INVALID_DEVICE_TYPE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <name>device_type</name>                        <literal>CL_DEVICE_TYPE_CUSTOM</literal>
                    </bit_and>
                    <or>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_CPU</literal>
                        </bit_and>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_GPU</literal>
                        </bit_and>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_ACCELERATOR</literal>
                        </bit_and>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_DEFAULT</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>device_type is not compatible</log>
                <name>clGetDeviceIDs</name>                             <value>CL_INVALID_DEVICE_TYPE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>num_entries</name>                        <literal>0</literal>
                    </eq>
                    <neq>
                        <name>devices</name>                            <literal>NULL</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>num_entries is equal to zero and devices is not NULL</log>
                <name>clGetDeviceIDs</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>num_devices</name>                        <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>devices</name>                            <literal>NULL</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>both num_devices and devices are NULL</log>
                <name>clGetDeviceIDs</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>devices</name>                            <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>devices</name>                            <name>num_entries</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>devices is too short</log>
                <name>clGetDeviceIDs</name>                             <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetDeviceInfo</name></proto>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_device_info</type>                          <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>      <log>device is not a valid device</log>
                <name>clGetDeviceInfo</name>                            <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetDeviceInfo</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetDeviceInfo</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetDeviceInfo</name>                            <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_1"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetDeviceAndHostTimer</name></proto>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_ulong</type>*                               <name>device_timestamp</name></param>
            <param><type>cl_ulong</type>*                               <name>host_timestamp</name></param>

            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>      <log>device is not a valid device</log>
                <name>clGetDeviceAndHostTimer</name>                    <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <eq>
                    <literal>0</literal>                                <query object="device" property="CL_PLATFORM_HOST_TIMER_RESOLUTION"/>
                </eq>
            </if>
            <then>      <log>the platform associated with device does not support device and host timer synchronization</log>
                <name>clGetDeviceAndHostTimer</name>                    <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <eq>
                    <name>host_timestamp</name>                         <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>host_timestamp is NULL</log>
                <name>clGetDeviceAndHostTimer</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>device_timestamp</name>                       <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>device_timestamp is NULL</log>
                <name>clGetDeviceAndHostTimer</name>                    <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_1"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetHostTimer</name></proto>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_ulong</type>*                               <name>host_timestamp</name></param>

            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>      <log>device is not a valid device</log>
                <name>clGetHostTimer</name>                             <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <eq>
                    <literal>0</literal>                                <query object="device" property="CL_PLATFORM_HOST_TIMER_RESOLUTION"/>
                </eq>
            </if>
            <then>      <log>the platform associated with device does not support device and host timer synchronization</log>
                <name>clGetHostTimer</name>                             <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <eq>
                    <name>host_timestamp</name>                         <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>host_timestamp is NULL</log>
                <name>clGetHostTimer</name>                             <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 4.3 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clCreateSubDevices</name></proto>
            <param><type>cl_device_id</type>                            <name>in_device</name></param>
            <param>const <type>cl_device_partition_property</type>*     <name>properties</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param><type>cl_device_id</type>*                           <name>out_devices</name></param>
            <param><type>cl_uint</type>*                                <name>num_devices_ret</name></param>

            <if>
                <object_is_invalid name="in_device"/>
            </if>
            <then>      <log>in_device is not a valid device</log>
                <name>clCreateSubDevices</name>                         <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <list_violation name="properties"/>
            </if>
            <then>      <log>values specified in properties are not valid</log>
                <name>clCreateSubDevices</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if values specified in properties are valid but not supported by the device -->
            <!-- CL_DEVICE_PARTITION_FAILED if the partition name is supported by the implementation but in_device could not be further partitioned -->
            <if>
                <list_violation name="properties" param="in_device"/>
            </if>
            <then>      <log>the partition name specified in properties is CL_DEVICE_PARTITION_BY_COUNTS and the number of sub-devices requested exceeds CL_DEVICE_PARTITION_MAX_SUB_DEVICES or the total number of compute units requested exceeds CL_DEVICE_MAX_COMPUTE_UNITS for in_device, or the number of compute units requested for one or more sub-devices is less than zero or the number of sub-devices requested exceeds CL_DEVICE_MAX_COMPUTE_UNITS for in_device</log>
                <name>clCreateSubDevices</name>                         <value>CL_INVALID_DEVICE_PARTITION_COUNT</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>out_devices</name>                        <literal>NULL</literal>
                    </neq>
                    <list_violation name="properties" param="in_device, num_devices"/>
                </and>
            </if>
            <then>      <log>out_devices is not NULL and num_devices is less than the number of sub-devices created by the partition scheme</log>
                <name>clCreateSubDevices</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>out_devices</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>out_devices</name>                        <name>num_devices</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>out_devices is too short</log>
                <name>clCreateSubDevices</name>                         <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clRetainDevice</name></proto>
            <param><type>cl_device_id</type>                            <name>device</name></param>

            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>      <log>device is not a valid device</log>
                <name>clRetainDevice</name>                             <value>CL_INVALID_DEVICE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clReleaseDevice</name></proto>
            <param><type>cl_device_id</type>                            <name>device</name></param>

            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>      <log>device is not a valid device</log>
                <name>clReleaseDevice</name>                            <value>CL_INVALID_DEVICE</value>
            </then>
        </command>

    <!-- 4.4 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_context</type>                              <name>clCreateContext</name></proto>
            <param>const <type>cl_context_properties</type>*            <name>properties</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param>const <type>cl_device_id</type>*                     <name>devices</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(const char* errinfo, const void* private_info, size_t cb, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <and>
                    <!-- TODO: This check should be somewhere else <from version="1.1"/> -->
                    <list_violation name="properties"/>
                </and>
            </if>
            <then>      <log>context property name in properties is not a supported property name or the same property name is specified more than once</log>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PROPERTY</value>
            </then>
            <if>
                <and>
                    <not>
                        <from version="1.1"/>
                    </not>
                    <list_violation name="properties"/>
                </and>
            </if>
            <then>      <log>context property name in properties is not a supported property name or the same property name is specified more than once</log>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_PLATFORM if properties is NULL and no platform could be selected -->
            <if>
                <list_violation name="properties" param="user_data"/>
            </if>
            <then>      <log>platform value specified in properties is not a valid platform</log>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PLATFORM</value>
            </then>
            <!-- CL_INVALID_PROPERTY if the value specified for a supported property name is not valid. This error code is missing before version 1.1 - CL_INVALID_VALUE should be used instead.
            platform is checked already, only cl_bool CL_CONTEXT_INTEROP_USER_SYNC can be checked, but do we need it? -->
            <if>
                <eq>
                    <name>devices</name>                                <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>devices is NULL</log>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>num_devices</name>                            <literal>0</literal>
                </eq>
            </if>
            <then>      <log>num_devices is equal to zero</log>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>devices</name>                                <name>num_devices</name>
                </array_len_ls>
            </if>
            <then>      <log>devices is too short</log>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <any_invalid array="devices" elements="num_devices"/>
            </if>
            <then>      <log>some device in devices is not a valid device</log>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <any_not_available array="devices" elements="num_devices"/>
            </if>
            <then>      <log>a device in devices is currently not available</log>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_DEVICE_NOT_AVAILABLE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>pfn_notify</name>                         <literal>NULL</literal>
                    </eq>
                    <neq>
                        <name>user_data</name>                          <literal>NULL</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>pfn_notify is NULL but user_data is not NULL</log>
                <name>clCreateContext</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_context</type>                              <name>clCreateContextFromType</name></proto>
            <param>const <type>cl_context_properties</type>*            <name>properties</name></param>
            <param><type>cl_device_type</type>                          <name>device_type</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(const char* errinfo, const void* private_info, size_t cb, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <and>
                    <!-- TODO: we cannot always query this version <from version="1.2"/> -->
                    <list_violation name="properties"/>
                </and>
            </if>
            <then>      <log>context property name in properties is not a supported property name or the same property name is specified more than once</log>
                <name>clCreateContextFromType</name>                    <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PROPERTY</value>
            </then>
            <if>
                <and>
                    <not>
                        <from version="1.1"/>
                    </not>
                    <list_violation name="properties"/>
                </and>
            </if>
            <then>      <log>context property name in properties is not a supported property name or the same property name is specified more than once</log>
                <name>clCreateContextFromType</name>                    <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_PLATFORM if properties is NULL and no platform could be selected -->
            <if>
                <list_violation name="properties" param="user_data"/>
            </if>
            <then>      <log>platform value specified in properties is not a valid platform</log>
                <name>clCreateContextFromType</name>                    <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PLATFORM</value>
            </then>
            <!-- CL_INVALID_PROPERTY if the value specified for a supported property name is not valid. This error code is missing before version 1.1 - CL_INVALID_VALUE should be used instead.
            platform is checked already, only cl_bool CL_CONTEXT_INTEROP_USER_SYNC can be checked, but do we need it? -->
            <if>
                <and>
                    <eq>
                        <name>pfn_notify</name>                         <literal>NULL</literal>
                    </eq>
                    <neq>
                        <name>user_data</name>                          <literal>NULL</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>pfn_notify is NULL but user_data is not NULL</log>
                <name>clCreateContextFromType</name>                    <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <bitfield_violation name="device_type"/>
                    <eq>
                        <name>device_type</name>                        <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>device_type is not a valid value</log>
                <name>clCreateContextFromType</name>                    <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE_TYPE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <name>device_type</name>                        <literal>CL_DEVICE_TYPE_CUSTOM</literal>
                    </bit_and>
                    <or>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_CPU</literal>
                        </bit_and>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_GPU</literal>
                        </bit_and>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_ACCELERATOR</literal>
                        </bit_and>
                        <bit_and>
                            <name>device_type</name>                    <literal>CL_DEVICE_TYPE_DEFAULT</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>device_type is not compatible</log>
                <name>clCreateContextFromType</name>                    <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE_TYPE</value>
            </then>
            <!-- don't think it is not "going into implementation"
            CL_DEVICE_NOT_AVAILABLE if no devices that match device_type and property values specified in properties are currently available.
            CL_DEVICE_NOT_FOUND if no devices that match device_type and property values specified in properties were found. -->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clRetainContext</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a vaild context</log>
                <name>clRetainContext</name>                            <value>CL_INVALID_CONTEXT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clReleaseContext</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a vaild context</log>
                <name>clReleaseContext</name>                           <value>CL_INVALID_CONTEXT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetContextInfo</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_context_info</type>                         <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a vaild context</log>
                <name>clGetContextInfo</name>                           <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetContextInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetContextInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetContextInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_3_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clSetContextDestructorCallback</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(cl_context context, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a vaild context</log>
                <name>clSetContextDestructorCallback</name>             <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <name>pfn_notify</name>                             <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>pfn_notify is NULL</log>
                <name>clSetContextDestructorCallback</name>             <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.1 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>cl_command_queue</type>                        <name>clCreateCommandQueueWithProperties</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param>const <type>cl_queue_properties</type>*              <name>properties</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateCommandQueueWithProperties</name>         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>      <log>device is not a valid device</log>
                <name>clCreateCommandQueueWithProperties</name>         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <object_not_in object="device" in="context"/>
            </if>
            <then>      <log>device is not associated with context</log>
                <name>clCreateCommandQueueWithProperties</name>         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <list_violation name="properties"/>
            </if>
            <then>      <log>values specified in properties are not valid</log>
                <name>clCreateCommandQueueWithProperties</name>         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- it is possible that device has additional limitations, for example
            it is not possible before 3.0 to query device about device queue support -->
                <list_violation name="properties" param="device"/>
            </if>
            <then>      <log>values specified in properties are valid but are not supported by the device</log>
                <name>clCreateCommandQueueWithProperties</name>         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_QUEUE_PROPERTIES</value>
            </then>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_2_DEPRECATED"> <!--DONE-->
            <proto><type>cl_command_queue</type>                        <name>clCreateCommandQueue</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_command_queue_properties</type>             <name>properties</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateCommandQueue</name>                       <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>      <log>device is not a valid device</log>
                <name>clCreateCommandQueue</name>                       <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <object_not_in object="device" in="context"/>
            </if>
            <then>      <log>device is not associated with context</log>
                <name>clCreateCommandQueue</name>                       <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <not>
                    <or>
                        <eq>
                            <name>properties</name>                         <literal>0</literal>
                        </eq>
                        <bit_and>
                            <name>properties</name>                         <literal>CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</literal>
                        </bit_and>
                        <bit_and>
                            <name>properties</name>                         <literal>CL_QUEUE_PROFILING_ENABLE</literal>
                        </bit_and>
                    </or>
                </not>
            </if>
            <then>      <log>values specified in properties are not valid</log>
                <name>clCreateCommandQueue</name>                       <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_QUEUE_PROPERTIES if values specified in properties are valid but are not supported by the device -->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_1"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clSetDefaultDeviceCommandQueue</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a vaild context</log>
                <name>clSetDefaultDeviceCommandQueue</name>             <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>      <log>device is not a valid device</log>
                <name>clSetDefaultDeviceCommandQueue</name>             <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <object_not_in object="device" in="context"/>
            </if>
            <then>      <log>device is not associated with context</log>
                <name>clSetDefaultDeviceCommandQueue</name>             <value>CL_INVALID_DEVICE</value>
            </then>
            <if> <!-- from 3.0 only -->
                <and>
                    <from version="3.0"/>
                    <not>
                        <bit_and>
                            <query object="device" property="CL_DEVICE_DEVICE_ENQUEUE_CAPABILITIES"/>
                            <literal>CL_DEVICE_QUEUE_REPLACEABLE_DEFAULT</literal>
                        </bit_and>
                    </not>
                </and>
            </if>
            <then>      <log>device does not support a replaceable default on-device queue</log>
                <name>clSetDefaultDeviceCommandQueue</name>             <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clSetDefaultDeviceCommandQueue</name>             <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="device"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue for device</log>
                <name>clSetDefaultDeviceCommandQueue</name>             <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <not>
                    <bit_and>
                        <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                        <literal>CL_QUEUE_ON_DEVICE</literal>
                    </bit_and>
                </not>
            </if>
            <then>      <log>command_queue is not a device-side command-queue for device</log>
                <name>clSetDefaultDeviceCommandQueue</name>             <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clRetainCommandQueue</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clRetainCommandQueue</name>                       <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clReleaseCommandQueue</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clReleaseCommandQueue</name>                      <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetCommandQueueInfo</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_command_queue_info</type>                   <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clGetCommandQueueInfo</name>                      <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>param_name</name>                         <literal>CL_QUEUE_SIZE</literal>
                    </eq>
                    <not>
                        <bit_and>
                            <literal>CL_QUEUE_ON_DEVICE</literal>       <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                        </bit_and>
                    </not>
                </and>
            </if>
            <then>      <log>command_queue is not a valid command-queue for param_name</log>
                <name>clGetCommandQueueInfo</name>                      <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not one of the supported values</log>
                <name>clGetCommandQueueInfo</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetCommandQueueInfo</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetCommandQueueInfo</name>                      <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0_DEPRECATED"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clSetCommandQueueProperty</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_command_queue_properties</type>             <name>properties</name></param>
            <param><type>cl_bool</type>                                 <name>enable</name></param>
            <param><type>cl_command_queue_properties</type>*            <name>old_properties</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clSetCommandQueueProperty</name>                  <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <not>
                    <or>
                        <bit_and>
                            <name>properties</name>                     <literal>CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE</literal>
                        </bit_and>
                        <bit_and>
                            <name>properties</name>                     <literal>CL_QUEUE_PROFILING_ENABLE</literal>
                        </bit_and>
                    </or>
                </not>
            </if>
            <then>      <log>values specified in properties are not valid</log>
                <name>clSetCommandQueueProperty</name>                  <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_QUEUE_PROPERTIES if values specified in properties are valid but are not supported by the device -->
        </command>

    <!-- 5.2.1 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_mem</type>                                  <name>clCreateBuffer</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>void</type>*                                   <name>host_ptr</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if> <!-- spec is not clear whether 0 is a valid value-->
                <or>
                    <bitfield_violation name="flags"/>
                    <eq>
                        <name>flags</name>                              <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>values specified in flags are not valid</log>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </bit_and>
                    </mutex_violation>
                </or>
            </if>
            <then>      <log>values specified in flags are not compatible</log>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>size</name>                                   <literal>0</literal>
                </eq>
            </if>
            <then>      <log>size is 0</log>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_BUFFER_SIZE</value>
            </then>
            <if>
                <for_any in="context" query="CL_DEVICE_MAX_MEM_ALLOC_SIZE">
                    <gt>
                        <name>size</name>                               <name>query</name>
                    </gt>
                </for_any>
            </if>
            <then>      <log>size is greater than CL_DEVICE_MAX_MEM_ALLOC_SIZE for all devices in context</log>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_BUFFER_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </eq>
                    <or>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>host_ptr is NULL but CL_MEM_USE_HOST_PTR or CL_MEM_COPY_HOST_PTR are set in flags</log>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <not>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </not>
                    <not>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                    </not>
                </and>
            </if>
            <then>      <log>host_ptr is not NULL but CL_MEM_COPY_HOST_PTR or CL_MEM_USE_HOST_PTR are not set in flags</log>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>host_ptr</name>                           <name>size</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>host_ptr is too short</log>
                <name>clCreateBuffer</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_3_0"> <!--DONE-->
            <proto><type>cl_mem</type>                                  <name>clCreateBufferWithProperties</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param>const <type>cl_mem_properties</type>*                <name>properties</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>void</type>*                                   <name>host_ptr</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <list_violation name="properties"/>
            </if>
            <then>      <log>a property name in properties is not a supported property name, or the value specified for a supported property name is not valid, or the same property name is specified more than once</log>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PROPERTY</value>
            </then>
            <if> <!-- spec is not clear whether 0 is a valid value-->
                <or>
                    <bitfield_violation name="flags"/>
                    <eq>
                        <name>flags</name>                              <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>values specified in flags are not valid</log>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </bit_and>
                    </mutex_violation>
                </or>
            </if>
            <then>      <log>values specified in flags are not compatible</log>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>size</name>                                   <literal>0</literal>
                </eq>
            </if>
            <then>      <log>size is 0</log>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_BUFFER_SIZE</value>
            </then>
            <if>
                <for_all in="context" query="CL_DEVICE_MAX_MEM_ALLOC_SIZE">
                    <gt>
                        <name>size</name>                               <name>query</name>
                    </gt>
                </for_all>
            </if>
            <then>      <log>size is greater than CL_DEVICE_MAX_MEM_ALLOC_SIZE for all devices in context</log>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_BUFFER_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </eq>
                    <or>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>host_ptr is NULL but CL_MEM_USE_HOST_PTR or CL_MEM_COPY_HOST_PTR are set in flags</log>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <not>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </not>
                    <not>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                    </not>
                </and>
            </if>
            <then>      <log>host_ptr is not NULL but CL_MEM_COPY_HOST_PTR or CL_MEM_USE_HOST_PTR are not set in flags</log>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>host_ptr</name>                           <name>size</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>host_ptr is too short</log>
                <name>clCreateBufferWithProperties</name>               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1"> <!--DONE-->
            <proto><type>cl_mem</type>                                  <name>clCreateSubBuffer</name></proto>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param><type>cl_buffer_create_type</type>                   <name>buffer_create_type</name></param>
            <param>const <type>void</type>*                             <name>buffer_create_info</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>      <log>buffer is not a valid mem object</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="buffer" type="CL_MEM_OBJECT_BUFFER"/>
            </if>
            <then>      <log>buffer is not a valid buffer object</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <neq>
                   <literal>NULL</literal>                              <query object="buffer" property="CL_MEM_ASSOCIATED_MEMOBJECT"/>
                </neq>
            </if>
            <then>      <log>buffer is a sub-buffer object</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <literal>CL_MEM_WRITE_ONLY</literal>            <query object="buffer" property="CL_MEM_FLAGS"/>
                    </bit_and>
                    <or>
                        <bit_and>
                            <name>flags</flags>                         <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</flags>                         <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>buffer was created with CL_MEM_WRITE_ONLY but flags specifies CL_MEM_READ_WRITE or CL_MEM_READ_ONLY</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <literal>CL_MEM_READ_ONLY</literal>             <query object="buffer" property="CL_MEM_FLAGS"/>
                    </bit_and>
                    <or>
                        <bit_and>
                            <name>flags</flags>                         <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</flags>                         <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>buffer was created with CL_MEM_READ_ONLY but flags specifies CL_MEM_READ_WRITE or CL_MEM_WRITE_ONLY</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <bit_and>
                        <name>flags</flags>                             <literal>CL_MEM_USE_HOST_PTR</literal>
                    </bit_and>
                    <bit_and>
                        <name>flags</flags>                             <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                    </bit_and>
                    <bit_and>
                        <name>flags</flags>                             <literal>CL_MEM_COPY_HOST_PTR</literal>
                    </bit_and>
                </or>
            </if>
            <then>      <log>flags specifies CL_MEM_USE_HOST_PTR or CL_MEM_ALLOC_HOST_PTR or CL_MEM_COPY_HOST_PTR</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <literal>CL_MEM_HOST_WRITE_ONLY</literal>       <query object="buffer" property="CL_MEM_FLAGS"/>
                    </bit_and>
                    <bit_and>
                        <name>flags</flags>                             <literal>CL_MEM_HOST_READ_ONLY</literal>
                    </bit_and>
                </and>
            </if>
            <then>      <log>buffer was created with CL_MEM_HOST_WRITE_ONLY but flags specify CL_MEM_HOST_READ_ONLY</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <literal>CL_MEM_HOST_READ_ONLY</literal>        <query object="buffer" property="CL_MEM_FLAGS"/>
                    </bit_and>
                    <bit_and>
                        <name>flags</flags>                             <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                    </bit_and>
                </and>
            </if>
            <then>      <log>buffer was created with CL_MEM_HOST_READ_ONLY but flags specify CL_MEM_HOST_WRITE_ONLY</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <literal>CL_MEM_HOST_NO_ACCESS</literal>        <query object="buffer" property="CL_MEM_FLAGS"/>
                    </bit_and>
                    <or>
                        <bit_and>
                            <name>flags</flags>                         <literal>CL_MEM_HOST_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</flags>                         <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>buffer was created with CL_MEM_HOST_NO_ACCESS but flags specify CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_WRITE_ONLY</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <enum_violation name="buffer_create_type"/>
            </if>
            <then>      <log>the value specified in buffer_create_type is not valid</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>buffer_create_info</name>                     <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>buffer_create_info is NULL</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>buffer_create_info</name>                     <literal_list>buffer_create_type</literal_list>
                </array_len_ls>
            </if>
            <then>      <log>buffer_create_info is too short</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- impossible now -->
                <struct_violation name="buffer_create_info" param="buffer_create_type"/>
            </if>
            <then>      <log>value(s) specified in buffer_create_info (for a given buffer_create_type) is not valid</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>buffer_create_type</name>                 <literal>CL_BUFFER_CREATE_TYPE_REGION</literal>
                    </eq>
                    <struct_violation name="buffer_create_info" param="buffer"/>
                </and>
            </if>
            <then>      <log>the region specified by the cl_buffer_region structure passed in buffer_create_info is out of bounds in buffer</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>buffer_create_type</name>                 <literal>CL_BUFFER_CREATE_TYPE_REGION</literal>
                    </eq>
                    <struct_violation name="buffer_create_info"/>
                </and>
            </if>
            <then>      <log>the size field of the cl_buffer_region structure passed in buffer_create_info is 0</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_BUFFER_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>buffer_create_type</name>                 <literal>CL_BUFFER_CREATE_TYPE_REGION</literal>
                    </eq>
                    <struct_violation name="buffer_create_info" param="buffer_create_type, buffer"/>
                </and>
            </if>
            <then>      <log>there are no devices in context associated with buffer for which the origin field of the cl_buffer_region structure passed in buffer_create_info is aligned to the CL_DEVICE_MEM_BASE_ADDR_ALIGN value</log>
                <name>clCreateSubBuffer</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_MISALIGNED_SUB_BUFFER_OFFSET</value>
            </then>
        </command>

    <!-- 5.2.2 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueReadBuffer</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_read</name></param>
            <param><type>size_t</type>                                  <name>offset</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>void</type>*                                   <name>ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>      <log>buffer is not a valid mem object</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="buffer" type="CL_MEM_OBJECT_BUFFER"/>
            </if>
            <then>      <log>buffer is not a valid buffer object</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>      <log>the context associated with command_queue and buffer are not the same</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <name>ptr</name>                                    <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>ptr is a NULL value</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>ptr</name>                                    <name>size</name>
                </array_len_ls>
            </if>
            <then>      <log>ptr is too short</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <gt>
                    <add>
                        <name>offset</name>
                        <name>size</name>
                    </add>                                              <query object="buffer" property="CL_MEM_SIZE"/>
                </gt>
            </if>
            <then>      <log>the region being read specified by (offset, size) is out of bounds</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <neq>
                        <mod>
                            <query object="buffer" property="CL_MEM_OFFSET"/>
                            <query object="command_queue" property="CL_DEVICE_MEM_BASE_ADDR_ALIGN"/>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_MISALIGNED_SUB_BUFFER_OFFSET</value>
            </then>
            <if>
                <or>
                    <bit_and>
                        <literal>CL_MEM_HOST_WRITE_ONLY</literal>       <query object="buffer" property="CL_MEM_FLAGS"/>
                    </bit_and>
                    <bit_and>
                        <literal>CL_MEM_HOST_NO_ACCESS</literal>        <query object="buffer" property="CL_MEM_FLAGS"/>
                    </bit_and>
                </or>
            </if>
            <then>      <log>buffer has been created with CL_MEM_HOST_WRITE_ONLY or CL_MEM_HOST_NO_ACCESS</log>
                <name>clEnqueueReadBuffer</name>                        <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueWriteBuffer</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_write</name></param>
            <param><type>size_t</type>                                  <name>offset</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param>const <type>void</type>*                             <name>ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>      <log>buffer is not a valid mem object</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="buffer" type="CL_MEM_OBJECT_BUFFER"/>
            </if>
            <then>      <log>buffer is not a valid buffer object</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>      <log>the context associated with command_queue and buffer are not the same</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <name>ptr</name>                                    <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>ptr is a NULL value</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>ptr</name>                                    <name>size</name>
                </array_len_ls>
            </if>
            <then>      <log>ptr is too short</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <gt>
                    <add>
                        <name>offset</name>
                        <name>size</name>
                    </add>                                              <query object="buffer" property="CL_MEM_SIZE"/>
                </gt>
            </if>
            <then>      <log>the region being written specified by (offset, size) is out of bounds</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <neq>
                        <mod>
                            <query object="buffer" property="CL_MEM_OFFSET"/>
                            <query object="command_queue" property="CL_DEVICE_MEM_BASE_ADDR_ALIGN"/>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_MISALIGNED_SUB_BUFFER_OFFSET</value>
            </then>
            <if>
                <or>
                    <bit_and>
                        <literal>CL_MEM_HOST_READ_ONLY</literal>        <query object="buffer" property="CL_MEM_FLAGS"/>
                    </bit_and>
                    <bit_and>
                        <literal>CL_MEM_HOST_NO_ACCESS</literal>        <query object="buffer" property="CL_MEM_FLAGS"/>
                    </bit_and>
                </or>
            </if>
            <then>      <log>buffer has been created with CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_NO_ACCESS</log>
                <name>clEnqueueWriteBuffer</name>                       <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueReadBufferRect</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_read</name></param>
            <param>const <type>size_t</type>*                           <name>buffer_origin</name></param>
            <param>const <type>size_t</type>*                           <name>host_origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>                                  <name>buffer_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>buffer_slice_pitch</name></param>
            <param><type>size_t</type>                                  <name>host_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>host_slice_pitch</name></param>
            <param><type>void</type>*                                   <name>ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>      <log>buffer is not a valid mem object</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="buffer" type="CL_MEM_OBJECT_BUFFER"/>
            </if>
            <then>      <log>buffer is not a valid buffer object</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>      <log>the context associated with command_queue and buffer are not the same</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>buffer_origin</name>                      <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>host_origin</name>                        <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>buffer_origin, host_origin, or region is NULL</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>buffer_origin</name>                      <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>host_origin</name>                        <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>      <log>buffer_origin, host_origin, or region is too short</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>some region array element is 0</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>buffer_row_pitch</name>                   <literal>0</literal>
                    </neq>
                    <ls>
                        <name>buffer_row_pitch</name>                   <name>region[0]</name>
                    </ls>
                </and>
            </if>
            <then>      <log>buffer_row_pitch is not 0 and is less than region[0]</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_row_pitch</name>                     <literal>0</literal>
                    </neq>
                    <ls>
                        <name>host_row_pitch</name>                     <name>region[0]</name>
                    </ls>
                </and>
            </if>
            <then>      <log>host_row_pitch is not 0 and is less than region[0]</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>buffer_row_pitch</name>                   <literal>0</literal>
                    </neq>
                    <neq>
                        <name>buffer_slice_pitch</name>                 <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>buffer_slice_pitch</name>             <mult>
                                                                            <name>region[1]</name>
                                                                            <name>buffer_row_pitch</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>buffer_slice_pitch</name>
                                <name>buffer_row_pitch</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>buffer_slice_pitch is not 0 and is less than (region[1] * buffer_row_pitch) or not a multiple of buffer_row_pitch</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>buffer_row_pitch</name>                   <literal>0</literal>
                    </eq>
                    <neq>
                        <name>buffer_slice_pitch</name>                 <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>buffer_slice_pitch</name>             <mult>
                                                                            <name>region[1]</name>
                                                                            <name>region[0]</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>buffer_slice_pitch</name>
                                <name>region[0]</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>buffer_slice_pitch is not 0 and is less than (region[1] * buffer_row_pitch) or not a multiple of buffer_row_pitch</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_row_pitch</name>                     <literal>0</literal>
                    </neq>
                    <neq>
                        <name>host_slice_pitch</name>                   <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>host_slice_pitch</name>               <mult>
                                                                            <name>region[1]</name>
                                                                            <name>host_row_pitch</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>host_slice_pitch</name>
                                <name>host_row_pitch</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>host_slice_pitch is not 0 and is less than (region[1] * host_row_pitch) and not a multiple of host_row_pitch</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>host_row_pitch</name>                     <literal>0</literal>
                    </eq>
                    <neq>
                        <name>host_slice_pitch</name>                   <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>host_slice_pitch</name>               <mult>
                                                                            <name>region[1]</name>
                                                                            <name>region[0]</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>host_slice_pitch</name>
                                <name>region[0]</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>host_slice_pitch is not 0 and is less than (region[1] * host_row_pitch) and not a multiple of host_row_pitch</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <gt>
                    <add>
                        <mult>
                            <add>
                                <name>buffer_origin[2]</name>
                                <name>region[2]</name>
                                <literal>-1</literal>
                            </add>                                      <max>
                                                                            <name>buffer_slice_pitch</name>
                                                                            <mult>
                                                                                <name>region[1]</name>
                                                                                <max>
                                                                                    <name>buffer_row_pitch</name>
                                                                                    <name>region[0]</name>
                                                                                </max>
                                                                            </mult>
                                                                        </max>
                        </mult>
                        <mult>
                            <add>
                                <name>buffer_origin[1]</name>
                                <name>region[1]</name>
                                <literal>-1</literal>
                            </add>                                      <max>
                                                                            <name>buffer_row_pitch</name>
                                                                            <name>region[0]</name>
                                                                        </max>
                        </mult>
                        <name>buffer_origin[0]</name>
                        <name>region[0]</name>
                    </add>                                              <query object="buffer" property="CL_MEM_SIZE"/>
                </gt>
            </if>
            <then>      <log>the region being read specified by (buffer_origin, region, buffer_row_pitch, buffer_slice_pitch) is out of bounds</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>ptr</name>                                    <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>ptr is NULL</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>ptr</name>
                    <add>
                        <mult>
                            <add>
                                <name>host_origin[2]</name>
                                <name>region[2]</name>
                                <literal>-1</literal>
                            </add>                                      <max>
                                                                            <name>host_slice_pitch</name>
                                                                            <mult>
                                                                                <name>region[1]</name>
                                                                                <max>
                                                                                    <name>host_row_pitch</name>
                                                                                    <name>region[0]</name>
                                                                                </max>
                                                                            </mult>
                                                                        </max>
                        </mult>
                        <mult>
                            <add>
                                <name>host_origin[1]</name>
                                <name>region[1]</name>
                                <literal>-1</literal>
                            </add>                                      <max>
                                                                            <name>host_row_pitch</name>
                                                                            <name>region[0]</name>
                                                                        </max>
                        </mult>
                        <name>host_origin[0]</name>
                        <name>region[0]</name>
                    </add>
                </array_len_ls>
            </if>
            <then>      <log>the host region being written specified by (host_origin, region, host_row_pitch, host_slice_pitch) is out of bounds</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <neq>
                        <mod>
                            <query object="buffer" property="CL_MEM_OFFSET"/>
                            <query object="command_queue" property="CL_DEVICE_MEM_BASE_ADDR_ALIGN"/>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_MISALIGNED_SUB_BUFFER_OFFSET</value>
            </then>
            <if>
                <or>
                    <bit_and>
                        <literal>CL_MEM_HOST_WRITE_ONLY</literal>       <query object="buffer" property="CL_MEM_FLAGS"/>
                    </bit_and>
                    <bit_and>
                        <literal>CL_MEM_HOST_NO_ACCESS</literal>        <query object="buffer" property="CL_MEM_FLAGS"/>
                    </bit_and>
                </or>
            </if>
            <then>      <log>buffer has been created with CL_MEM_HOST_WRITE_ONLY or CL_MEM_HOST_NO_ACCESS</log>
                <name>clEnqueueReadBufferRect</name>                    <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueWriteBufferRect</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_write</name></param>
            <param>const <type>size_t</type>*                           <name>buffer_origin</name></param>
            <param>const <type>size_t</type>*                           <name>host_origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>                                  <name>buffer_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>buffer_slice_pitch</name></param>
            <param><type>size_t</type>                                  <name>host_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>host_slice_pitch</name></param>
            <param>const <type>void</type>*                             <name>ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>      <log>buffer is not a valid mem object</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="buffer" type="CL_MEM_OBJECT_BUFFER"/>
            </if>
            <then>      <log>buffer is not a valid buffer object</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>      <log>the context associated with command_queue and buffer are not the same</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>buffer_origin</name>                      <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>host_origin</name>                        <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>buffer_origin, host_origin, or region is NULL</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>buffer_origin</name>                      <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>host_origin</name>                        <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>      <log>buffer_origin, host_origin, or region is too short</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>some region array element is 0</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>buffer_row_pitch</name>                   <literal>0</literal>
                    </neq>
                    <ls>
                        <name>buffer_row_pitch</name>                   <name>region[0]</name>
                    </ls>
                </and>
            </if>
            <then>      <log>buffer_row_pitch is not 0 and is less than region[0]</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_row_pitch</name>                     <literal>0</literal>
                    </neq>
                    <ls>
                        <name>host_row_pitch</name>                     <name>region[0]</name>
                    </ls>
                </and>
            </if>
            <then>      <log>host_row_pitch is not 0 and is less than region[0]</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>buffer_row_pitch</name>                   <literal>0</literal>
                    </neq>
                    <neq>
                        <name>buffer_slice_pitch</name>                 <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>buffer_slice_pitch</name>             <mult>
                                                                            <name>region[1]</name>
                                                                            <name>buffer_row_pitch</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>buffer_slice_pitch</name>
                                <name>buffer_row_pitch</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>buffer_slice_pitch is not 0 and is less than region[1] * buffer_row_pitch or not a multiple of buffer_row_pitch</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>buffer_row_pitch</name>                   <literal>0</literal>
                    </eq>
                    <neq>
                        <name>buffer_slice_pitch</name>                 <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>buffer_slice_pitch</name>             <mult>
                                                                            <name>region[1]</name>
                                                                            <name>region[0]</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>buffer_slice_pitch</name>
                                <name>region[0]</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>buffer_slice_pitch is not 0 and is less than region[1] * buffer_row_pitch or not a multiple of buffer_row_pitch</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_row_pitch</name>                     <literal>0</literal>
                    </neq>
                    <neq>
                        <name>host_slice_pitch</name>                   <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>host_slice_pitch</name>               <mult>
                                                                            <name>region[1]</name>
                                                                            <name>host_row_pitch</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>host_slice_pitch</name>
                                <name>host_row_pitch</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>host_slice_pitch is not 0 and is less than region[1] * host_row_pitch and not a multiple of host_row_pitch</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>host_row_pitch</name>                     <literal>0</literal>
                    </eq>
                    <neq>
                        <name>host_slice_pitch</name>                   <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>host_slice_pitch</name>               <mult>
                                                                            <name>region[1]</name>
                                                                            <name>region[0]</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>host_slice_pitch</name>
                                <name>region[0]</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>host_slice_pitch is not 0 and is less than region[1] * host_row_pitch and not a multiple of host_row_pitch</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <gt>
                    <add>
                        <mult>
                            <add>
                                <name>buffer_origin[2]</name>
                                <name>region[2]</name>
                                <literal>-1</literal>
                            </add>                                      <max>
                                                                            <name>buffer_slice_pitch</name>
                                                                            <mult>
                                                                                <name>region[1]</name>
                                                                                <max>
                                                                                    <name>buffer_row_pitch</name>
                                                                                    <name>region[0]</name>
                                                                                </max>
                                                                            </mult>
                                                                        </max>
                        </mult>
                        <mult>
                            <add>
                                <name>buffer_origin[1]</name>
                                <name>region[1]</name>
                                <literal>-1</literal>
                            </add>                                      <max>
                                                                            <name>buffer_row_pitch</name>
                                                                            <name>region[0]</name>
                                                                        </max>
                        </mult>
                        <name>buffer_origin[0]</name>
                        <name>region[0]</name>
                    </add>                                              <query object="buffer" property="CL_MEM_SIZE"/>
                </gt>
            </if>
            <then>      <log>the region being written specified by (buffer_origin, region, buffer_row_pitch, buffer_slice_pitch) is out of bounds</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>ptr</name>                                    <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>ptr is NULL</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>ptr</name>
                    <add>
                        <mult>
                            <add>
                                <name>host_origin[2]</name>
                                <name>region[2]</name>
                                <literal>-1</literal>
                            </add>                                      <max>
                                                                            <name>host_slice_pitch</name>
                                                                            <mult>
                                                                                <name>region[1]</name>
                                                                                <max>
                                                                                    <name>host_row_pitch</name>
                                                                                    <name>region[0]</name>
                                                                                </max>
                                                                            </mult>
                                                                        </max>
                        </mult>
                        <mult>
                            <add>
                                <name>host_origin[1]</name>
                                <name>region[1]</name>
                                <literal>-1</literal>
                            </add>                                      <max>
                                                                            <name>host_row_pitch</name>
                                                                            <name>region[0]</name>
                                                                        </max>
                        </mult>
                        <name>host_origin[0]</name>
                        <name>region[0]</name>
                    </add>
                </array_len_ls>
            </if>
            <then>      <log>the host region being read specified by (host_origin, region, host_row_pitch, host_slice_pitch) is out of bounds</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <neq>
                        <mod>
                            <query object="buffer" property="CL_MEM_OFFSET"/>
                            <query object="command_queue" property="CL_DEVICE_MEM_BASE_ADDR_ALIGN"/>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_MISALIGNED_SUB_BUFFER_OFFSET</value>
            </then>
            <if>
                <or>
                    <bit_and>
                        <literal>CL_MEM_HOST_READ_ONLY</literal>        <query object="buffer" property="CL_MEM_FLAGS"/>
                    </bit_and>
                    <bit_and>
                        <literal>CL_MEM_HOST_NO_ACCESS</literal>        <query object="buffer" property="CL_MEM_FLAGS"/>
                    </bit_and>
                </or>
            </if>
            <then>      <log>buffer has been created with CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_NO_ACCESS</log>
                <name>clEnqueueWriteBufferRect</name>                   <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueCopyBuffer</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>src_buffer</name></param>
            <param><type>cl_mem</type>                                  <name>dst_buffer</name></param>
            <param><type>size_t</type>                                  <name>src_offset</name></param>
            <param><type>size_t</type>                                  <name>dst_offset</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="src_buffer"/>
            </if>
            <then>      <log>src_buffer is not a valid mem object</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="src_buffer" type="CL_MEM_OBJECT_BUFFER"/>
            </if>
            <then>      <log>src_buffer is not a valid buffer object</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="dst_buffer"/>
            </if>
            <then>      <log>dst_buffer is not a valid mem object</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="dst_buffer" type="CL_MEM_OBJECT_BUFFER"/>
            </if>
            <then>      <log>dst_buffer is not a valid buffer object</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="src_buffer"/>
            </if>
            <then>      <log>the context associated with command_queue and src_buffer are not the same</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="dst_buffer"/>
            </if>
            <then>      <log>the context associated with command_queue and dst_buffer are not the same</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <gt>
                    <add>
                        <name>src_offset</name>
                        <name>size</name>
                    </add>                                              <query object="src_buffer" property="CL_MEM_SIZE"/>
                </gt>
            </if>
            <then>      <log>the region being read specified by (src_offset, size) is out of bounds</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <gt>
                    <add>
                        <name>dst_offset</name>
                        <name>size</name>
                    </add>                                              <query object="dst_buffer" property="CL_MEM_SIZE"/>
                </gt>
            </if>
            <then>      <log>the region being written specified by (dst_offset, size) is out of bounds</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <neq>
                        <mod>
                            <query object="src_buffer" property="CL_MEM_OFFSET"/>
                            <query object="command_queue" property="CL_DEVICE_MEM_BASE_ADDR_ALIGN"/>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>src_buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_MISALIGNED_SUB_BUFFER_OFFSET</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <neq>
                        <mod>
                            <query object="dst_buffer" property="CL_MEM_OFFSET"/>
                            <query object="command_queue" property="CL_DEVICE_MEM_BASE_ADDR_ALIGN"/>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>dst_buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_MISALIGNED_SUB_BUFFER_OFFSET</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>src_buffer</name>                         <name>dst_buffer</name>
                    </eq>
                    <or>
                        <and>
                            <ls>
                                <name>src_offset</name>                 <add>
                                                                            <name>dst_offset</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <name>dst_offset</name>                 <add>
                                                                            <name>src_offset</name>
                                                                            <name>size</name>
                                                                        </add>
                            </ls>
                        </and>
                        <and>
                            <ls>
                                <name>dst_offset</name>                 <add>
                                                                            <name>src_offset</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <name>src_offset</name>                 <add>
                                                                            <name>dst_offset</name>
                                                                            <name>size</name>
                                                                        </add>
                            </ls>
                        </and>
                    </or>
                </and>
            </if>
            <then>      <log>src_buffer and dst_buffer are the same buffer or sub-buffer object and the source and destination regions overlap</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_MEM_COPY_OVERLAP</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <eq>
                        <name>src_buffer</name>                         <query object="dst_buffer" property="CL_MEM_ASSOCIATED_MEMOBJECT"/>
                    </eq>
                    <or>
                        <and>
                            <ls>
                                <name>src_offset</name>                 <add>
                                                                            <query object="dst_buffer" property="CL_MEM_OFFSET"/>
                                                                            <name>dst_offset</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <add>
                                    <query object="dst_buffer" property="CL_MEM_OFFSET"/>
                                    <name>dst_offset</name>
                                </add>                                  <add>
                                                                            <name>src_offset</name>
                                                                            <name>size</name>
                                                                        </add>
                            </ls>
                        </and>
                        <and>
                            <ls>
                                <add>
                                    <query object="dst_buffer" property="CL_MEM_OFFSET"/>
                                    <name>dst_offset</name>
                                </add>                                  <add>
                                                                            <name>src_offset</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <name>src_offset</name>                 <add>
                                                                            <query object="dst_buffer" property="CL_MEM_OFFSET"/>
                                                                            <name>dst_offset</name>
                                                                            <name>size</name>
                                                                        </add>
                            </ls>
                        </and>
                    </or>
                </and>
            </if>
            <then>      <log>dst_buffer is a sub-buffer of src_buffer and the source and destination regions overlap</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_MEM_COPY_OVERLAP</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <eq>
                        <name>dst_buffer</name>                         <query object="src_buffer" property="CL_MEM_ASSOCIATED_MEMOBJECT"/>
                    </eq>
                    <or>
                        <and>
                            <ls>
                                <add>
                                    <query object="src_buffer" property="CL_MEM_OFFSET"/>
                                    <name>src_offset</name>
                                </add>                                  <add>
                                                                            <name>dst_offset</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <name>dst_offset</name>                 <add>
                                                                            <query object="src_buffer" property="CL_MEM_OFFSET"/>
                                                                            <name>src_offset</name>
                                                                            <name>size</name>
                                                                        </add>
                            </ls>
                        </and>
                        <and>
                            <ls>
                                <name>dst_offset</name>                 <add>
                                                                            <query object="src_buffer" property="CL_MEM_OFFSET"/>
                                                                            <name>src_offset</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <add>
                                    <query object="src_buffer" property="CL_MEM_OFFSET"/>
                                    <name>src_offset</name>
                                </add>                                  <add>
                                                                            <name>dst_offset</name>
                                                                            <name>size</name>
                                                                        </add>
                            </ls>
                        </and>
                    </or>
                </and>
            </if>
            <then>      <log>src_buffer is a sub-buffer of dst_buffer and the source and destination regions overlap</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_MEM_COPY_OVERLAP</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <neq>
                        <literal>NULL</literal>                         <query object="src_buffer" property="CL_MEM_ASSOCIATED_MEMOBJECT"/>
                    </neq>
                    <eq>
                        <query object="src_buffer" property="CL_MEM_ASSOCIATED_MEMOBJECT"/>
                        <query object="dst_buffer" property="CL_MEM_ASSOCIATED_MEMOBJECT"/>
                    </eq>
                    <or>
                        <and>
                            <ls>
                                <add>
                                    <query object="src_buffer" property="CL_MEM_OFFSET"/>
                                    <name>src_offset</name>
                                </add>                                  <add>
                                                                            <query object="dst_buffer" property="CL_MEM_OFFSET"/>
                                                                            <name>dst_offset</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <add>
                                    <query object="dst_buffer" property="CL_MEM_OFFSET"/>
                                    <name>dst_offset</name>
                                </add>                                  <add>
                                                                            <query object="src_buffer" property="CL_MEM_OFFSET"/>
                                                                            <name>src_offset</name>
                                                                            <name>size</name>
                                                                        </add>
                            </ls>
                        </and>
                        <and>
                            <ls>
                                <add>
                                    <query object="dst_buffer" property="CL_MEM_OFFSET"/>
                                    <name>dst_offset</name>
                                </add>                                  <add>
                                                                            <query object="src_buffer" property="CL_MEM_OFFSET"/>
                                                                            <name>src_offset</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <add>
                                    <query object="src_buffer" property="CL_MEM_OFFSET"/>
                                    <name>src_offset</name>
                                </add>                                  <add>
                                                                            <query object="dst_buffer" property="CL_MEM_OFFSET"/>
                                                                            <name>dst_offset</name>
                                                                            <name>size</name>
                                                                        </add>
                            </ls>
                        </and>
                    </or>
                </and>
            </if>
            <then>      <log>src_buffer and dst_buffer are different sub-buffers of the same associated buffer object and the source and destination regions overlap</log>
                <name>clEnqueueCopyBuffer</name>                        <value>CL_MEM_COPY_OVERLAP</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueCopyBufferRect</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>src_buffer</name></param>
            <param><type>cl_mem</type>                                  <name>dst_buffer</name></param>
            <param>const <type>size_t</type>*                           <name>src_origin</name></param>
            <param>const <type>size_t</type>*                           <name>dst_origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>                                  <name>src_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>src_slice_pitch</name></param>
            <param><type>size_t</type>                                  <name>dst_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>dst_slice_pitch</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="src_buffer"/>
            </if>
            <then>      <log>src_buffer is not a valid mem object</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="src_buffer"/>
            </if>
            <then>      <log>src_buffer is not a valid buffer object</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="dst_buffer"/>
            </if>
            <then>      <log>dst_buffer is not a valid mem object</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="dst_buffer"/>
            </if>
            <then>      <log>dst_buffer is not a valid buffer object</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="src_buffer"/>
            </if>
            <then>      <log>the context associated with command_queue and src_buffer are not the same</log>
                <name>clEnqueueCopyBufferRect</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="dst_buffer"/>
            </if>
            <then>      <log>the context associated with command_queue and dst_buffer are not the same</log>
                <name>clEnqueueCopyBufferRect</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>src_origin</name>                         <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>dst_origin</name>                         <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>src_origin, dst_origin, or region is NULL</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>src_origin</name>                         <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>dst_origin</name>                         <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>      <log>src_origin, dst_origin, or region is too short</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>some region array element is 0</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>src_row_pitch</name>                      <literal>0</literal>
                    </neq>
                    <ls>
                        <name>src_row_pitch</name>                      <name>region[0]</name>
                    </ls>
                </and>
            </if>
            <then>      <log>src_row_pitch is not 0 and is less than region[0]</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>dst_row_pitch</name>                      <literal>0</literal>
                    </neq>
                    <ls>
                        <name>dst_row_pitch</name>                      <name>region[0]</name>
                    </ls>
                </and>
            </if>
            <then>      <log>dst_row_pitch is not 0 and is less than region[0]</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>src_row_pitch</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>src_slice_pitch</name>                    <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>src_slice_pitch</name>                <mult>
                                                                            <name>region[1]</name>
                                                                            <name>src_row_pitch</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>src_slice_pitch</name>
                                <name>src_row_pitch</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>src_slice_pitch is not 0 and is less than region[1] * src_row_pitch or not a multiple of src_row_pitch</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>src_row_pitch</name>                      <literal>0</literal>
                    </eq>
                    <neq>
                        <name>src_slice_pitch</name>                    <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>src_slice_pitch</name>                <mult>
                                                                            <name>region[1]</name>
                                                                            <name>region[0]</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>src_slice_pitch</name>
                                <name>region[0]</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>src_slice_pitch is not 0 and is less than region[1] * src_row_pitch or not a multiple of src_row_pitch</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>dst_row_pitch</name>                      <literal>0</literal>
                    </neq>
                    <neq>
                        <name>dst_slice_pitch</name>                    <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>dst_slice_pitch</name>                <mult>
                                                                            <name>region[1]</name>
                                                                            <name>dst_row_pitch</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>dst_slice_pitch</name>
                                <name>dst_row_pitch</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>dst_slice_pitch is not 0 and is less than region[1] * dst_row_pitch or not a multiple of dst_row_pitch</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>dst_row_pitch</name>                      <literal>0</literal>
                    </eq>
                    <neq>
                        <name>dst_slice_pitch</name>                    <literal>0</literal>
                    </neq>
                    <or>
                        <ls>
                            <name>dst_slice_pitch</name>                <mult>
                                                                            <name>region[1]</name>
                                                                            <name>region[0]</name>
                                                                        </mult>
                        </ls>
                        <neq>
                            <mod>
                                <name>dst_slice_pitch</name>
                                <name>region[0]</name>
                            </mod>                                      <literal>0</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>dst_slice_pitch is not 0 and is less than region[1] * dst_row_pitch or not a multiple of dst_row_pitch</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>dst_buffer</name>                         <name>src_buffer</name>
                    </eq>
                    <neq>
                        <max>
                            <name>dst_row_pitch</name>
                            <name>region[0]</name>
                        </max>                                          <max>
                                                                            <name>src_row_pitch</name>
                                                                            <name>region[0]</name>
                                                                        </max>
                    </neq>
                </and>
            </if>
            <then>      <log>src_buffer and dst_buffer are the same buffer object and src_row_pitch is not equal to dst_row_pitch</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>dst_buffer</name>                         <name>src_buffer</name>
                    </eq>
                    <neq>
                        <max>
                            <name>dst_slice_pitch</name>
                            <mult>
                                <max>
                                    <name>dst_row_pitch</name>
                                    <name>region[0]</name>
                                </max>
                                <name>region[1]</name>
                            </mult>
                        </max>                                          <max>
                                                                            <name>src_slice_pitch</name>
                                                                            <mult>
                                                                                <max>
                                                                                    <name>src_row_pitch</name>
                                                                                    <name>region[0]</name>
                                                                                </max>
                                                                                <name>region[1]</name>
                                                                            </mult>
                                                                        </max>
                    </neq>
                </and>
            </if>
            <then>      <log>src_buffer and dst_buffer are the same buffer object and src_slice_pitch is not equal to dst_slice_pitch</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <gt>
                    <add>
                        <mult>
                            <add>
                                <name>src_origin[2]</name>
                                <name>region[2]</name>
                                <literal>-1</literal>
                            </add>                                      <max>
                                                                            <name>src_slice_pitch</name>
                                                                            <mult>
                                                                                <name>region[1]</name>
                                                                                <max>
                                                                                    <name>src_row_pitch</name>
                                                                                    <name>region[0]</name>
                                                                                </max>
                                                                            </mult>
                                                                        </max>
                        </mult>
                        <mult>
                            <add>
                                <name>src_origin[1]</name>
                                <name>region[1]</name>
                                <literal>-1</literal>
                            </add>                                      <max>
                                                                            <name>src_row_pitch</name>
                                                                            <name>region[0]</name>
                                                                        </max>
                        </mult>
                        <name>src_origin[0]</name>
                        <name>region[0]</name>
                    </add>                                              <query object="src_buffer" property="CL_MEM_SIZE"/>
                </gt>
            </if>
            <then>      <log>the region being read specified by (src_origin, region, src_row_pitch, src_slice_pitch) is out of bounds</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <gt>
                    <add>
                        <mult>
                            <add>
                                <name>dst_origin[2]</name>
                                <name>region[2]</name>
                                <literal>-1</literal>
                            </add>                                      <max>
                                                                            <name>dst_slice_pitch</name>
                                                                            <mult>
                                                                                <name>region[1]</name>
                                                                                <max>
                                                                                    <name>dst_row_pitch</name>
                                                                                    <name>region[0]</name>
                                                                                </max>
                                                                            </mult>
                                                                        </max>
                        </mult>
                        <mult>
                            <add>
                                <name>dst_origin[1]</name>
                                <name>region[1]</name>
                                <literal>-1</literal>
                            </add>                                      <max>
                                                                            <name>dst_row_pitch</name>
                                                                            <name>region[0]</name>
                                                                        </max>
                        </mult>
                        <name>dst_origin[0]</name>
                        <name>region[0]</name>
                    </add>                                              <query object="dst_buffer" property="CL_MEM_SIZE"/>
                </gt>
            </if>
            <then>      <log>the region being read specified by (dst_origin, region, dst_row_pitch, dst_slice_pitch) is out of bounds</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <neq>
                        <mod>
                            <query object="src_buffer" property="CL_MEM_OFFSET"/>
                            <query object="command_queue" property="CL_DEVICE_MEM_BASE_ADDR_ALIGN"/>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>src_buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_MISALIGNED_SUB_BUFFER_OFFSET</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <neq>
                        <mod>
                            <query object="dst_buffer" property="CL_MEM_OFFSET"/>
                            <query object="command_queue" property="CL_DEVICE_MEM_BASE_ADDR_ALIGN"/>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>dst_buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue</log>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_MISALIGNED_SUB_BUFFER_OFFSET</value>
            </then>
            <if> <!-- can be done in XML -->
                <check_copy_overlap param="src_origin, dst_origin, region, src_row_pitch, src_slice_pitch"/>
            </if>
            <then>
                <name>clEnqueueCopyBufferRect</name>                    <value>CL_MEM_COPY_OVERLAP</value>
            </then>
        </command>

    <!-- 5.2.3 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueFillBuffer</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param>const <type>void</type>*                             <name>pattern</name></param>
            <param><type>size_t</type>                                  <name>pattern_size</name></param>
            <param><type>size_t</type>                                  <name>offset</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>      <log>buffer is not a valid mem object</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>      <log>buffer is not a valid buffer object</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>      <log>the context associated with command_queue and buffer are not the same</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <gt>
                    <add>
                        <name>offset</name>
                        <name>size</name>
                    </add>                                              <query object="buffer" property="CL_MEM_SIZE"/>
                </gt>
            </if>
            <then>      <log>the region being filled specified by (offset, size) is out of bounds</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>pattern</name>                                <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>pattern is NULL</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>pattern_size</name>                       <literal>1</literal>
                    </neq>
                    <neq>
                        <name>pattern_size</name>                       <literal>2</literal>
                    </neq>
                    <neq>
                        <name>pattern_size</name>                       <literal>4</literal>
                    </neq>
                    <neq>
                        <name>pattern_size</name>                       <literal>8</literal>
                    </neq>
                    <neq>
                        <name>pattern_size</name>                       <literal>16</literal>
                    </neq>
                    <neq>
                        <name>pattern_size</name>                       <literal>32</literal>
                    </neq>
                    <neq>
                        <name>pattern_size</name>                       <literal>64</literal>
                    </neq>
                    <neq> <!-- can be not supported on embedded devices -->
                        <name>pattern_size</name>                       <literal>128</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>pattern_size is not one of { 1, 2, 4, 8, 16, 32, 64, 128 }</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>pattern</name>                                <name>pattern_size</name>
                </array_len_ls>
            </if>
            <then>      <log>pattern is too short</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <neq>
                    <mod>
                        <name>offset</name>
                        <name>pattern_size</name>
                    </mod>                                              <literal>0</literal>
                </neq>
            </if>
            <then>      <log>offset is not a multiple of pattern_size</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <neq>
                    <mod>
                        <name>size</name>
                        <name>pattern_size</name>
                    </mod>                                              <literal>0</literal>
                </neq>
            </if>
            <then>      <log>size is not a multiple of pattern_size</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <neq>
                        <mod>
                            <query object="buffer" property="CL_MEM_OFFSET"/>
                            <query object="command_queue" property="CL_DEVICE_MEM_BASE_ADDR_ALIGN"/>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue</log>
                <name>clEnqueueFillBuffer</name>                        <value>CL_MISALIGNED_SUB_BUFFER_OFFSET</value>
            </then>
        </command>

    <!-- 5.2.4 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>void</type>*                                   <name>clEnqueueMapBuffer</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>buffer</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_map</name></param>
            <param><type>cl_map_flags</type>                            <name>map_flags</name></param>
            <param><type>size_t</type>                                  <name>offset</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="buffer"/>
            </if>
            <then>      <log>buffer is not a valid mem object</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>      <log>buffer is not a valid buffer object</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="buffer"/>
            </if>
            <then>      <log>the context associated with command_queue and buffer are not the same</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <gt>
                    <add>
                        <name>offset</name>
                        <name>size</name>
                    </add>                                              <query object="buffer" property="CL_MEM_SIZE"/>
                </gt>
            </if>
            <then>      <log>the region being written specified by (offset, size) is out of bounds</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>size</name>                                   <literal>0</literal>
                </eq>
            </if>
            <then>      <log>size is 0</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <bitfield_violation name="map_flags"/>
                    <eq>
                        <name>map_flags</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>values specified in map_flags are not valid</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <name>map_flags</name>                          <literal>CL_MAP_WRITE_INVALIDATE_REGION</literal>
                    </bit_and>
                    <or>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_READ</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>values specified in map_flags are not compatible</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <neq>
                        <mod>
                            <query object="buffer" property="CL_MEM_OFFSET"/>
                            <query object="command_queue" property="CL_DEVICE_MEM_BASE_ADDR_ALIGN"/>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_MISALIGNED_SUB_BUFFER_OFFSET</value>
            </then>
            <if>
                <and>
                    <or>
                        <bit_and>
                            <literal>CL_MEM_HOST_WRITE_ONLY</literal>   <query object="buffer" property="CL_MEM_FLAGS"/>
                        </bit_and>
                        <bit_and>
                            <literal>CL_MEM_HOST_NO_ACCESS</literal>    <query object="buffer" property="CL_MEM_FLAGS"/>
                        </bit_and>
                    </or>
                    <bit_and>
                        <name>map_flags</name>                          <literal>CL_MAP_READ</literal>
                    </bit_and>
                </and>
            </if>
            <then>      <log>buffer has been created with CL_MEM_HOST_WRITE_ONLY or CL_MEM_HOST_NO_ACCESS and CL_MAP_READ is set in map_flags</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <and>
                    <or>
                        <bit_and>
                            <literal>CL_MEM_HOST_READ_ONLY</literal>    <query object="buffer" property="CL_MEM_FLAGS"/>
                        </bit_and>
                        <bit_and>
                            <literal>CL_MEM_HOST_NO_ACCESS</literal>    <query object="buffer" property="CL_MEM_FLAGS"/>
                        </bit_and>
                    </or>
                    <or>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_WRITE_INVALIDATE_REGION</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>buffer has been created with CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_NO_ACCESS and CL_MAP_WRITE or CL_MAP_WRITE_INVALIDATE_REGION is set in map_flags</log>
                <name>clEnqueueMapBuffer</name>                         <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

    <!-- 5.3.1 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_mem</type>                                  <name>clCreateImage</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param>const <type>cl_image_format</type>*                  <name>image_format</name></param>
            <param>const <type>cl_image_desc</type>*                    <name>image_desc</name></param>
            <param><type>void</type>*                                   <name>host_ptr</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if> <!-- spec is not clear whether 0 is a valid value-->
                <or>
                    <bitfield_violation name="flags"/>
                    <eq>
                        <name>flags</name>                              <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>values specified in flags are not valid</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </bit_and>
                    </mutex_violation>
                    <!-- TODO: fix <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_USE_HOST_PTR</literal>
                    </bit_and>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                    </bit_and>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_COPY_HOST_PTR</literal>
                    </bit_and> -->
                </or>
            </if>
            <then>      <log>values specified in flags are not compatible</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>image_format</name>                           <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>image_format is NULL</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <!-- 1 element only needed
            <if>
                <array_len_ls>
                    <name>image_format</name>                           <literal>1</literal>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>-->
            <if>
                <struct_violation name="image_format"/>
            </if>
            <then>      <log>values specified in image_format are not valid</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <eq>
                    <name>image_desc</name>                             <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>image_desc is NULL</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_DESCRIPTOR</value>
            </then>
            <!-- 1 element only needed
            <if>
                <array_len_ls>
                    <name>image_desc</name>                             <literal>1</literal>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_DESCRIPTOR</value>
            </then> -->
            <if>
                <struct_violation name="image_format" param="context, image_desc"/>
            </if>
            <then>      <log>a 2D image is created from a buffer but row pitch or base address alignment is invalid</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <struct_violation name="image_format" param="image_desc"/>
            </if>
            <then>      <log>a 2D image is created from a 2D image object but image descriptors are not compatible</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <struct_violation name="image_desc" param="image_format, host_ptr"/>
            </if>
            <then>      <log>values specified in image_desc are not valid</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_DESCRIPTOR</value>
            </then>
            <if>
                <struct_violation name="image_desc" param="context"/>
            </if>
            <then>      <log>image dimensions specified in image_desc exceed the maximum image dimensions for all devices in context</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <struct_violation name="image_desc" param="flags"/>
            </if>
            <then>      <log>an image is being created from another memory object and flags are not compatible</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <struct_violation name="image_desc" param="host_ptr, image_format"/>
            </if>
            <then>      <log>an image is being created from host_ptr that is too short</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </eq>
                    <or>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>host_ptr is NULL and CL_MEM_USE_HOST_PTR or CL_MEM_COPY_HOST_PTR are set in flags</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <and>
                        <not>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_USE_HOST_PTR</literal>
                            </bit_and>
                        </not>
                        <not>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_COPY_HOST_PTR</literal>
                            </bit_and>
                        </not>
                    </and>
                </and>
            </if>
            <then>      <log>host_ptr is not NULL but CL_MEM_COPY_HOST_PTR or CL_MEM_USE_HOST_PTR are not set in flags</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <for_all in="context" query="CL_DEVICE_IMAGE_SUPPORT">
                    <eq>
                        <literal>CL_FALSE</literal>                     <name>query</name>
                    </eq>
                </for_all>
            </if>
            <then>      <log>there are no devices in context that support images</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <struct_violation name="image_format" param="image_desc, context"/>
            </if>
            <then>      <log>a 2D image is created from a buffer but there are no devices in context that support it</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <struct_violation name="image_format" param="context, flags, image_desc"/>
            </if>
            <then>      <log>there are no devices in context that support image_format</log>
                <name>clCreateImage</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_IMAGE_FORMAT_NOT_SUPPORTED</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_3_0"> <!--DONE-->
            <proto><type>cl_mem</type>                                  <name>clCreateImageWithProperties</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param>const <type>cl_mem_properties</type>*                <name>properties</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param>const <type>cl_image_format</type>*                  <name>image_format</name></param>
            <param>const <type>cl_image_desc</type>*                    <name>image_desc</name></param>
            <param><type>void</type>*                                   <name>host_ptr</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <list_violation name="properties"/>
            </if>
            <then>      <log>a property name in properties is not a supported property name, if the value specified for a supported property name is not valid, or if the same property name is specified more than once</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PROPERTY</value>
            </then>
            <if> <!-- spec is not clear whether 0 is a valid value-->
                <or>
                    <bitfield_violation name="flags"/>
                    <eq>
                        <name>flags</name>                              <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>values specified in flags are not valid</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </bit_and>
                    </mutex_violation>
                    <!-- TODO: fix <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_USE_HOST_PTR</literal>
                    </bit_and>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                    </bit_and>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_COPY_HOST_PTR</literal>
                    </bit_and> -->
                </or>
            </if>
            <then>      <log>values specified in flags are not compatible</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>image_format</name>                           <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>image_format is NULL</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <!-- 1 element only needed
            <if>
                <array_len_ls>
                    <name>image_format</name>                           <literal>1</literal>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>-->
            <if>
                <struct_violation name="image_format"/>
            </if>
            <then>      <log>values specified in image_format are not valid</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <eq>
                    <name>image_desc</name>                             <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>image_desc is NULL</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_DESCRIPTOR</value>
            </then>
            <!-- 1 element only needed
            <if>
                <array_len_ls>
                    <name>image_desc</name>                             <literal>1</literal>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_DESCRIPTOR</value>
            </then> -->
            <if>
                <struct_violation name="image_format" param="context, image_desc"/>
            </if>
            <then>      <log>a 2D image is created from a buffer but row pitch or base address alignment is invalid</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <struct_violation name="image_format" param="image_desc"/>
            </if>
            <then>      <log>a 2D image is created from a 2D image object but image descriptors are not compatible</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <struct_violation name="image_desc" param="image_format, host_ptr"/>
            </if>
            <then>      <log>values specified in image_desc are not valid</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_DESCRIPTOR</value>
            </then>
            <if>
                <struct_violation name="image_desc" param="context"/>
            </if>
            <then>      <log>image dimensions specified in image_desc exceed the maximum image dimensions for all devices in context</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <struct_violation name="image_desc" param="flags"/>
            </if>
            <then>      <log>an image is being created from another memory object and flags are not compatible</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <struct_violation name="image_desc" param="host_ptr, image_format"/>
            </if>
            <then>      <log>an image is being created from host_ptr that is too short</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </eq>
                    <or>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>host_ptr is NULL and CL_MEM_USE_HOST_PTR or CL_MEM_COPY_HOST_PTR are set in flags</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <and>
                        <not>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_USE_HOST_PTR</literal>
                            </bit_and>
                        </not>
                        <not>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_COPY_HOST_PTR</literal>
                            </bit_and>
                        </not>
                    </and>
                </and>
            </if>
            <then>      <log>host_ptr is not NULL but CL_MEM_COPY_HOST_PTR or CL_MEM_USE_HOST_PTR are not set in flags</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <for_all in="context" query="CL_DEVICE_IMAGE_SUPPORT">
                    <eq>
                        <literal>CL_FALSE</literal>                     <name>query</name>
                    </eq>
                </for_all>
            </if>
            <then>      <log>there are no devices in context that support images</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <struct_violation name="image_format" param="context, flags, image_desc"/>
            </if>
            <then>      <log>there are no devices in context that support image_format</log>
                <name>clCreateImageWithProperties</name>                <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_IMAGE_FORMAT_NOT_SUPPORTED</value>
            </then>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_1_DEPRECATED"> <!--DONE-->
            <proto><type>cl_mem</type>                                  <name>clCreateImage2D</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param>const <type>cl_image_format</type>*                  <name>image_format</name></param>
            <param><type>size_t</type>                                  <name>image_width</name></param>
            <param><type>size_t</type>                                  <name>image_height</name></param>
            <param><type>size_t</type>                                  <name>image_row_pitch</name></param>
            <param><type>void</type>*                                   <name>host_ptr</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if> <!-- 0 is valid here-->
                <bitfield_violation name="flags"/>
            </if>
            <then>      <log>values specified in flags are not valid</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </bit_and>
                    </mutex_violation>
                </or>
            </if>
            <then>      <log>values specified in flags are not compatible</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>image_format</name>                           <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>image_format is NULL</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <!-- 1 element only needed
            <if>
                <array_len_ls>
                    <name>image_format</name>                           <literal>1</literal>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>-->
            <if>
                <struct_violation name="image_format"/>
            </if>
            <then>      <log>values specified in image_format are not valid</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>image_width</name>                        <literal>0</literal>
                    </eq>
                    <eq>
                        <name>image_height</name>                       <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>image_width or image_height are 0</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <struct_violation name="context" param="image_width, image_height"/>
            </if>
            <then>      <log>image_width and image_height exceed the maximum values for all devices in context</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </eq>
                    <neq>
                        <name>image_row_pitch</name>                    <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>host_ptr is NULL but image_row_pitch is not 0</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <gt>
                        <name>image_row_pitch</name>                    <literal>0</literal>
                    </gt>
                    <ls>
                        <name>image_row_pitch</name>                    <mult>
                                                                            <name>image_width</name>
                                                                            <literal_list>image_format</literal_list>
                                                                        </mult>
                    </ls>
                </and>
            </if>
            <then>      <log>host_ptr is not NULL and image_row_pitch is in (0, image_width * size of image element in bytes) range</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <neq>
                        <mod>
                            <name>image_row_pitch</name>
                            <literal_list>image_format</literal_list>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>host_ptr is not NULL and image_row_pitch is not a multiple of the image element size in bytes</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </eq>
                    <or>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>host_ptr is NULL and CL_MEM_USE_HOST_PTR or CL_MEM_COPY_HOST_PTR are set in flags</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <and>
                        <not>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_USE_HOST_PTR</literal>
                            </bit_and>
                        </not>
                        <not>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_COPY_HOST_PTR</literal>
                            </bit_and>
                        </not>
                    </and>
                </and>
            </if>
            <then>      <log>host_ptr is not NULL but CL_MEM_COPY_HOST_PTR or CL_MEM_USE_HOST_PTR are not set in flags</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>host_ptr</name>                               <mult>
                                                                            <name>image_height</name>
                                                                            <max>
                                                                                <name>image_row_pitch</name>
                                                                                <mult>
                                                                                    <name>image_width</name>
                                                                                    <literal_list>image_format</literal_list>
                                                                                </mult>
                                                                            </max>
                                                                        </mult>
                </array_len_ls>
            </if>
            <then>      <log>an image is being created from host_ptr that is too short</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <for_all in="context" query="CL_DEVICE_IMAGE_SUPPORT">
                    <eq>
                        <literal>CL_FALSE</literal>                     <name>query</name>
                    </eq>
                </for_all>
            </if>
            <then>      <log>there are no devices in context that support images</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <struct_violation name="image_format" param="context, flags, CL_MEM_OBJECT_IMAGE2D"/>
            </if>
            <then>      <log>there are no devices in context that support image_format</log>
                <name>clCreateImage2D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_IMAGE_FORMAT_NOT_SUPPORTED</value>
            </then>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_1_DEPRECATED"> <!--DONE-->
            <proto><type>cl_mem</type>                                  <name>clCreateImage3D</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param>const <type>cl_image_format</type>*                  <name>image_format</name></param>
            <param><type>size_t</type>                                  <name>image_width</name></param>
            <param><type>size_t</type>                                  <name>image_height</name></param>
            <param><type>size_t</type>                                  <name>image_depth</name></param>
            <param><type>size_t</type>                                  <name>image_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>image_slice_pitch</name></param>
            <param><type>void</type>*                                   <name>host_ptr</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if> <!-- 0 is valid here-->
                <bitfield_violation name="flags"/>
            </if>
            <then>      <log>values specified in flags are not valid</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_ALLOC_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                    </mutex_violation>
                    <mutex_violation>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </bit_and>
                    </mutex_violation>
                </or>
            </if>
            <then>      <log>values specified in flags are not compatible</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>image_format</name>                           <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>image_format is NULL</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <!-- 1 element only needed
            <if>
                <array_len_ls>
                    <name>image_format</name>                           <literal>1</literal>
                </array_len_ls>
            </if>
            <then>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>-->
            <if>
                <struct_violation name="image_format"/>
            </if>
            <then>      <log>values specified in image_format are not valid</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_FORMAT_DESCRIPTOR</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>image_width</name>                        <literal>0</literal>
                    </eq>
                    <eq>
                        <name>image_height</name>                       <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>image_width or image_height are 0</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <ls>
                    <name>image_depth</name>                            <literal>2</literal>
                </ls>
            </if>
            <then>      <log>image_depth is not &gt; 1</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <struct_violation name="context" param="image_width, image_height, image_depth"/>
            </if>
            <then>      <log>image_width, image_height, and image_depth exceed the maximum values for all devices in context</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </eq>
                    <neq>
                        <name>image_row_pitch</name>                    <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>host_ptr is NULL but image_row_pitch is not 0</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <gt>
                        <name>image_row_pitch</name>                    <literal>0</literal>
                    </gt>
                    <ls>
                        <name>image_row_pitch</name>                    <mult>
                                                                            <name>image_width</name>
                                                                            <literal_list>image_format</literal_list>
                                                                        </mult>
                    </ls>
                </and>
            </if>
            <then>      <log>host_ptr is not NULL and image_row_pitch is in (0, image_width * size of image element in bytes) range</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <neq>
                        <mod>
                            <name>image_row_pitch</name>
                            <literal_list>image_format</literal_list>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>host_ptr is not NULL and image_row_pitch is not a multiple of the image element size in bytes</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </eq>
                    <neq>
                        <name>image_slice_pitch</name>                  <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>host_ptr is NULL but image_slice_pitch is not 0</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <gt>
                        <name>image_slice_pitch</name>                  <literal>0</literal>
                    </gt>
                    <ls>
                        <name>image_slice_pitch</name>                  <mult>
                                                                            <name>image_height</name>
                                                                            <max>
                                                                                <name>image_row_pitch</name>
                                                                                <mult>
                                                                                    <name>image_width</name>
                                                                                    <literal_list>image_format</literal_list>
                                                                                </mult>
                                                                            </max>
                                                                        </mult>
                    </ls>
                </and>
            </if>
            <then>      <log>host_ptr is not NULL and image_slice_pitch is in (0, image_height * image_row_pitch) range</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <neq>
                        <mod>
                            <name>image_slice_pitch</name>
                            <max>
                                <name>image_row_pitch</name>
                                <mult>
                                    <name>image_width</name>
                                    <literal_list>image_format</literal_list>
                                </mult>
                            </max>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>host_ptr is not NULL and image_slice_pitch is not a multiple of the image_row_pitch</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </eq>
                    <or>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_USE_HOST_PTR</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_COPY_HOST_PTR</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>host_ptr is NULL and CL_MEM_USE_HOST_PTR or CL_MEM_COPY_HOST_PTR are set in flags</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>host_ptr</name>                           <literal>NULL</literal>
                    </neq>
                    <and>
                        <not>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_USE_HOST_PTR</literal>
                            </bit_and>
                        </not>
                        <not>
                            <bit_and>
                                <name>flags</name>                      <literal>CL_MEM_COPY_HOST_PTR</literal>
                            </bit_and>
                        </not>
                    </and>
                </and>
            </if>
            <then>      <log>host_ptr is not NULL but CL_MEM_COPY_HOST_PTR or CL_MEM_USE_HOST_PTR are not set in flags</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>host_ptr</name>                               <mult>
                                                                            <name>image_depth</name>
                                                                            <max>
                                                                                <name>image_slice_pitch</name>
                                                                                <mult>
                                                                                    <name>image_height</name>
                                                                                    <max>
                                                                                        <name>image_row_pitch</name>
                                                                                        <mult>
                                                                                            <name>image_width</name>
                                                                                            <literal_list>image_format</literal_list>
                                                                                        </mult>
                                                                                    </max>
                                                                                </mult>
                                                                            </max>
                                                                        </mult>
                </array_len_ls>
            </if>
            <then>      <log>an image is being created from host_ptr that is too short</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_HOST_PTR</value>
            </then>
            <if>
                <for_all in="context" query="CL_DEVICE_IMAGE_SUPPORT">
                    <eq>
                        <literal>CL_FALSE</literal>                     <name>query</name>
                    </eq>
                </for_all>
            </if>
            <then>      <log>there are no devices in context that support images</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <struct_violation name="image_format" param="context, flags, CL_MEM_OBJECT_IMAGE3D"/>
            </if>
            <then>      <log>there are no devices in context that support image_format</log>
                <name>clCreateImage3D</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_IMAGE_FORMAT_NOT_SUPPORTED</value>
            </then>
        </command>

    <!-- 5.3.2 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetSupportedImageFormats</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param><type>cl_mem_object_type</type>                      <name>image_type</name></param>
            <param><type>cl_uint</type>                                 <name>num_entries</name></param>
            <param><type>cl_image_format</type>*                        <name>image_formats</name></param>
            <param><type>cl_uint</type>*                                <name>num_image_formats</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clGetSupportedImageFormats</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <not>
                    <or>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_READ_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_WRITE_ONLY</literal>
                        </bit_and>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_KERNEL_READ_AND_WRITE</literal>
                        </bit_and>
                    </or>
                </not>
            </if>
            <then>      <log>flags are not valid</log>
                <name>clGetSupportedImageFormats</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <not>
                    <or>
                        <eq>
                            <name>image_type</name>                     <literal>CL_MEM_OBJECT_IMAGE1D</literal>
                        </eq>
                        <eq>
                            <name>image_type</name>                     <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal>
                        </eq>
                        <eq>
                            <name>image_type</name>                     <literal>CL_MEM_OBJECT_IMAGE2D</literal>
                        </eq>
                        <eq>
                            <name>image_type</name>                     <literal>CL_MEM_OBJECT_IMAGE3D</literal>
                        </eq>
                        <eq>
                            <name>image_type</name>                     <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>
                        </eq>
                        <eq>
                            <name>image_type</name>                     <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>
                        </eq>
                    </or>
                </not>
            </if>
            <then>      <log>image_type is not valid</log>
                <name>clGetSupportedImageFormats</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>num_entries</name>                        <literal>0</literal>
                    </eq>
                    <neq>
                        <name>image_formats</name>                      <literal>NULL</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>num_entries is 0 and image_formats is not NULL</log>
                <name>clGetSupportedImageFormats</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>image_formats</name>                      <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>image_formats</name>                      <name>num_entries</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>image_formats is too short</log>
                <name>clGetSupportedImageFormats</name>                 <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.3.3 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueReadImage</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>image</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_read</name></param>
            <param>const <type>size_t</type>*                           <name>origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>                                  <name>row_pitch</name></param>
            <param><type>size_t</type>                                  <name>slice_pitch</name></param>
            <param><type>void</type>*                                   <name>ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="image"/>
            </if>
            <then>      <log>image is not a valid mem object</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>image is not a valid image object</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="image"/>
            </if>
            <then>      <log>the context associated with command_queue and image are not the same</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>origin</name>                             <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>origin or region is NULL</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>origin</name>                             <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>      <log>origin or region is too short</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>some region array element is 0</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0.
                If image is a 1D image array object, origin[2] must be 0.
                If image is a 2D image object, region[2] must be 1.
                If image is a 1D image array object, region[2] must be 1. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="image" property="CL_MEM_TYPE"/>                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>origin[2]</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>wrong origin or region values for 2D image or 1D image array</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0.
                If image is a 1D image or 1D image buffer object, region[1] and region[2] must be 1. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal>  <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>origin[1]</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>origin[2]</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[1]</name>                      <literal>1</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
               </and>
            </if>
            <then>      <log>wrong origin or region values for 1D image or 1D image buffer</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <neq>
                        <name>slice_pitch</name>                        <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>image is a 1D or 2D image but slice_pitch is not 0</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>row_pitch</name>                          <literal>0</literal>
                    </neq>
                    <ls>
                        <name>row_pitch</name>                          <mult>
                                                                            <name>region[0]</name>
                                                                            <query object="image" property="CL_IMAGE_ELEMENT_SIZE"/>
                                                                        </mult>
                    </ls>
                </and>
            </if>
            <then>      <log>row_pitch is not 0 and is less than (region[0] * element size in bytes)</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>slice_pitch</name>                        <literal>0</literal>
                    </neq>
                    <ls>
                        <name>slice_pitch</name>                        <mult>
                                                                            <name>region[1]</name>
                                                                            <max>
                                                                                <name>row_pitch</name>
                                                                                <mult>
                                                                                    <name>region[0]</name>
                                                                                    <query object="image" property="CL_IMAGE_ELEMENT_SIZE"/>
                                                                                </mult>
                                                                            </max>
                                                                        </mult>
                    </ls>
                </and>
            </if>
            <then>      <log>slice_pitch is not 0 and is less than (region[1] * row_pitch)</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 3D image</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 2D image array</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 2D image</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 1D image array</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="image" property="CL_IMAGE_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 1D image</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="image" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 1D image buffer</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_DEPTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, depth) for 3D image are not supported by device associated with queue</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, array size) for 2D image array are not supported by device associated with queue</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height) for 2D image are not supported by device associated with queue</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, array size) for 1D image array are not supported by device associated with queue</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image are not supported by device associated with queue</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image buffer are not supported by device associated with queue</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <eq>
                    <name>ptr</name>                                    <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>ptr is NULL</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>ptr</name>                                    <add>
                                                                            <mult>
                                                                                <add>
                                                                                    <name>region[2]</name>
                                                                                    <literal>-1</literal>
                                                                                </add>
                                                                                <max>
                                                                                    <name>slice_pitch</name>
                                                                                    <mult>
                                                                                        <name>region[1]</name>
                                                                                        <max>
                                                                                            <name>row_pitch</name>
                                                                                            <mult>
                                                                                                <name>region[0]</name>
                                                                                                <query object="image" property="CL_IMAGE_ELEMENT_SIZE"/>
                                                                                            </mult>
                                                                                        </max>
                                                                                    </mult>
                                                                                </max>
                                                                            </mult>
                                                                            <mult>
                                                                                <add>
                                                                                    <name>region[1]</name>
                                                                                    <literal>-1</literal>
                                                                                </add>
                                                                                <max>
                                                                                    <name>row_pitch</name>
                                                                                    <mult>
                                                                                        <name>region[0]</name>
                                                                                        <query object="image" property="CL_IMAGE_ELEMENT_SIZE"/>
                                                                                    </mult>
                                                                                </max>
                                                                            </mult>
                                                                            <mult>
                                                                                <name>region[0]</name>
                                                                                <query object="image" property="CL_IMAGE_ELEMENT_SIZE"/>
                                                                            </mult>
                                                                        </add>
                </array_len_ls>
            </if>
            <then>      <log>ptr is too short</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <literal>CL_FALSE</literal>                         <query object="command_queue" property="CL_DEVICE_IMAGE_SUPPORT"/>
                </eq>
            </if>
            <then>      <log>the device associated with command_queue does not support images</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <struct_violation name="image" param="command_queue"/>
            </if>
            <then>      <log>image format (image channel order and data type) for image are not supported by device associated with queue</log>
                <name>clEnqueueReadImage</name>                         <value>CL_IMAGE_FORMAT_NOT_SUPPORTED</value>
            </then>
            <if>
                <or>
                    <bit_and>
                        <literal>CL_MEM_HOST_WRITE_ONLY</literal>       <query object="image" property="CL_MEM_FLAGS"/>
                    </bit_and>
                    <bit_and>
                        <literal>CL_MEM_HOST_NO_ACCESS</literal>        <query object="image" property="CL_MEM_FLAGS"/>
                    </bit_and>
                </or>
            </if>
            <then>      <log>image has been created with CL_MEM_HOST_WRITE_ONLY or CL_MEM_HOST_NO_ACCESS and CL_MAP_READ is set in map_flags or if image has been created with CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_NO_ACCESS and CL_MAP_WRITE or CL_MAP_WRITE_INVALIDATE_REGION is set in map_flags</log>
                <name>clEnqueueReadImage</name>                         <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueWriteImage</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>image</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_write</name></param>
            <param>const <type>size_t</type>*                           <name>origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>                                  <name>input_row_pitch</name></param>
            <param><type>size_t</type>                                  <name>input_slice_pitch</name></param>
            <param>const <type>void</type>*                             <name>ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>image is not a valid image object</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="image"/>
            </if>
            <then>      <log>the context associated with command_queue and image are not the same</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>origin</name>                             <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>origin or region is NULL</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>origin</name>                             <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>      <log>origin or region is too short</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>some region array element is 0</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0.
                If image is a 1D image array object, origin[2] must be 0.
                If image is a 2D image object, region[2] must be 1.
                If image is a 1D image array object, region[2] must be 1. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>origin[2]</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>wrong origin or region values for 2D image or 1D image array</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0.
                If image is a 1D image or 1D image buffer object, region[1] and region[2] must be 1. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal>  <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>origin[1]</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>origin[2]</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[1]</name>                      <literal>1</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
               </and>
            </if>
            <then>      <log>wrong origin or region values for 1D image or 1D buffer</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <neq>
                        <name>input_slice_pitch</name>                  <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>image is a 1D or 2D image but slice_pitch is not 0</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>input_row_pitch</name>                    <literal>0</literal>
                    </neq>
                    <ls>
                        <name>input_row_pitch</name>                    <mult>
                                                                            <name>region[0]</name>
                                                                            <query object="image" property="CL_IMAGE_ELEMENT_SIZE"/>
                                                                        </mult>
                    </ls>
                </and>
            </if>
            <then>      <log>input_row_pitch is not 0 and is less than (region[0] * element size in bytes)</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>input_slice_pitch</name>                  <literal>0</literal>
                    </neq>
                    <ls>
                        <name>input_slice_pitch</name>                  <mult>
                                                                            <name>region[1]</name>
                                                                            <max>
                                                                                <name>input_row_pitch</name>
                                                                                <mult>
                                                                                    <name>region[0]</name>
                                                                                    <query object="image" property="CL_IMAGE_ELEMENT_SIZE"/>
                                                                                </mult>
                                                                            </max>
                                                                        </mult>
                    </ls>
                </and>
            </if>
            <then>      <log>input_slice_pitch is not 0 and is less than (region[1] * input_row_pitch)</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being written specified by origin and region is out of bounds for 3D image</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being written specified by origin and region is out of bounds for 2D image array</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being written specified by origin and region is out of bounds for 2D image</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being written specified by origin and region is out of bounds for 1D image array</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="image" property="CL_IMAGE_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being written specified by origin and region is out of bounds for 1D image</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="image" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being written specified by origin and region is out of bounds for 1D image buffer</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_DEPTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, depth) for 3D image are not supported by device associated with queue</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, array size) for 2D image array are not supported by device associated with queue</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height) for 2D image are not supported by device associated with queue</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, array size) for 1D image array are not supported by device associated with queue</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image are not supported by device associated with queue</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image buffer are not supported by device associated with queue</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <eq>
                    <name>ptr</name>                                    <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>ptr is NULL</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>ptr</name>                                    <add>
                                                                            <mult>
                                                                                <add>
                                                                                    <name>region[2]</name>
                                                                                    <literal>-1</literal>
                                                                                </add>
                                                                                <max>
                                                                                    <name>input_slice_pitch</name>
                                                                                    <mult>
                                                                                        <name>region[1]</name>
                                                                                        <max>
                                                                                            <name>input_row_pitch</name>
                                                                                            <mult>
                                                                                                <name>region[0]</name>
                                                                                                <query object="image" property="CL_IMAGE_ELEMENT_SIZE"/>
                                                                                            </mult>
                                                                                        </max>
                                                                                    </mult>
                                                                                </max>
                                                                            </mult>
                                                                            <mult>
                                                                                <add>
                                                                                    <name>region[1]</name>
                                                                                    <literal>-1</literal>
                                                                                </add>
                                                                                <max>
                                                                                    <name>input_row_pitch</name>
                                                                                    <mult>
                                                                                        <name>region[0]</name>
                                                                                        <query object="image" property="CL_IMAGE_ELEMENT_SIZE"/>
                                                                                    </mult>
                                                                                </max>
                                                                            </mult>
                                                                            <mult>
                                                                                <name>region[0]</name>
                                                                                <query object="image" property="CL_IMAGE_ELEMENT_SIZE"/>
                                                                            </mult>
                                                                        </add>
                </array_len_ls>
            </if>
            <then>      <log>ptr is too short</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <literal>CL_FALSE</literal>                         <query object="command_queue" property="CL_DEVICE_IMAGE_SUPPORT"/>
                </eq>
            </if>
            <then>      <log>the device associated with command_queue does not support images</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <struct_violation name="image" param="command_queue"/>
            </if>
            <then>      <log>image format (image channel order and data type) for image are not supported by device associated with queue</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_IMAGE_FORMAT_NOT_SUPPORTED</value>
            </then>
            <if>
                <or>
                    <bit_and>
                        <literal>CL_MEM_HOST_READ_ONLY</literal>        <query object="image" property="CL_MEM_FLAGS"/>
                    </bit_and>
                    <bit_and>
                        <literal>CL_MEM_HOST_NO_ACCESS</literal>        <query object="image" property="CL_MEM_FLAGS"/>
                    </bit_and>
                </or>
            </if>
            <then>      <log>image which has been created with CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_NO_ACCESS</log>
                <name>clEnqueueWriteImage</name>                        <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueCopyImage</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>src_image</name></param>
            <param><type>cl_mem</type>                                  <name>dst_image</name></param>
            <param>const <type>size_t</type>*                           <name>src_origin</name></param>
            <param>const <type>size_t</type>*                           <name>dst_origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="src_image"/>
            </if>
            <then>      <log>src_image is not a valid mem object</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>src_image is not a valid image object</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="dst_image"/>
            </if>
            <then>      <log>dst_image is not a valid mem object</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>dst_image is not a valid image object</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="src_image"/>
            </if>
            <then>      <log>the context associated with command_queue and src_image are not the same</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="dst_image"/>
            </if>
            <then>      <log>the context associated with command_queue and dst_image are not the same</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <struct_violation name="src_image" param="dst_image"/>
            </if>
            <then>      <log>src_image and dst_image do not use the same image format</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_IMAGE_FORMAT_MISMATCH</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>src_origin</name>                         <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>dst_origin</name>                         <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>src_origin, dst_origin, or region is NULL</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>src_origin</name>                         <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>dst_origin</name>                         <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>      <log>src_origin, dst_origin or region is too short</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>some region array element is 0</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0.
                If image is a 1D image array object, origin[2] must be 0. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="src_image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>src_origin[2]</name>                  <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>wrong origin or region values for 2D image or 1D image array src_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="src_image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>src_origin[1]</name>                  <literal>0</literal>
                        </neq>
                        <neq>
                            <name>src_origin[2]</name>                  <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[1]</name>                      <literal>1</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
               </and>
            </if>
            <then>      <log>wrong origin or region values for 1D image or 1D image buffer src_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0.
                If image is a 1D image array object, origin[2] must be 0. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="dst_image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>dst_origin[2]</name>                  <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>wrong origin or region values for 2D image or 1D image array dst_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="dst_image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>dst_origin[1]</name>                  <literal>0</literal>
                        </neq>
                        <neq>
                            <name>dst_origin[2]</name>                  <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[1]</name>                      <literal>1</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
               </and>
            </if>
            <then>      <log>wrong origin or region values for 1D image or 1D image buffer dst_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>src_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>src_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>src_origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 3D image src_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>src_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>src_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>src_origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 2D image array src_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>src_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>src_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 2D image src_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>src_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>src_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 1D image array src_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>src_origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="src_image" property="CL_IMAGE_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 1D image src_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>src_origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="src_image" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 1D image buffer src_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>dst_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>dst_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>dst_origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 3D image dst_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>dst_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>dst_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>dst_origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 2D image array dst_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>dst_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>dst_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 2D image dst_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>dst_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>dst_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 1D image array dst_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>dst_origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 1D image dst_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>dst_origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="dst_image" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being read specified by origin and region is out of bounds for 1D image buffer dst_image</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_DEPTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, depth) for 3D image src_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, array size) for 2D image array src_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height) for 2D image src_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, array size) for 1D image array src_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="src_image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image src_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="src_image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image buffer src_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_DEPTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, depth) for 3D image dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, array size) for 2D image array dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height) for 2D image dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, array size) for 1D image array dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image buffer dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <literal>CL_FALSE</literal>                         <query object="command_queue" property="CL_DEVICE_IMAGE_SUPPORT"/>
                </eq>
            </if>
            <then>      <log>the device associated with command_queue does not support images</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <struct_violation name="src_image" param="command_queue"/>
            </if>
            <then>      <log>image format (image channel order and data type) for src_image and dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_IMAGE_FORMAT_NOT_SUPPORTED</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>src_image</name>                          <name>dst_image</name>
                    </eq>
                    <or>
                        <and>
                            <ls>
                                <name>src_origin[0]</name>              <add>
                                                                            <name>dst_origin[0]</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <name>dst_origin[0]</name>              <add>
                                                                            <name>src_origin[0]</name>
                                                                            <name>region[0]</name>
                                                                        </add>
                            </ls>
                        </and>
                        <and>
                            <ls>
                                <name>dst_origin[0]</name>              <add>
                                                                            <name>src_origin[0]</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <name>src_origin[0]</name>              <add>
                                                                            <name>dst_origin[0]</name>
                                                                            <name>region[0]</name>
                                                                        </add>
                            </ls>
                        </and>
                    </or>
                    <or>
                        <and>
                            <ls>
                                <name>src_origin[1]</name>              <add>
                                                                            <name>dst_origin[1]</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <name>dst_origin[1]</name>              <add>
                                                                            <name>src_origin[1]</name>
                                                                            <name>region[1]</name>
                                                                        </add>
                            </ls>
                        </and>
                        <and>
                            <ls>
                                <name>dst_origin[1]</name>              <add>
                                                                            <name>src_origin[1]</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <name>src_origin[1]</name>              <add>
                                                                            <name>dst_origin[1]</name>
                                                                            <name>region[1]</name>
                                                                        </add>
                            </ls>
                        </and>
                    </or>
                    <or>
                        <and>
                            <ls>
                                <name>src_origin[2]</name>              <add>
                                                                            <name>dst_origin[2]</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <name>dst_origin[2]</name>              <add>
                                                                            <name>src_origin[2]</name>
                                                                            <name>region[2]</name>
                                                                        </add>
                            </ls>
                        </and>
                        <and>
                            <ls>
                                <name>dst_origin[2]</name>              <add>
                                                                            <name>src_origin[2]</name>
                                                                            <literal>1</literal>
                                                                        </add>
                            </ls>
                            <ls>
                                <name>src_origin[2]</name>              <add>
                                                                            <name>dst_origin[2]</name>
                                                                            <name>region[2]</name>
                                                                        </add>
                            </ls>
                        </and>
                    </or>
                </and>
            </if>
            <then>      <log>src_image and dst_image are the same image object and the source and destination regions overlap</log>
                <name>clEnqueueCopyImage</name>                         <value>CL_MEM_COPY_OVERLAP</value>
            </then>
        </command>

    <!-- 5.3.4 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueFillImage</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>image</name></param>
            <param>const <type>void</type>*                             <name>fill_color</name></param>
            <param>const <type>size_t</type>*                           <name>origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="image"/>
            </if>
            <then>      <log>image is not a valid mem object</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>image is not a valid image object</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="image"/>
            </if>
            <then>      <log>context associated with command_queue and image are not the same</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <name>fill_color</name>                             <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>fill_color is NULL</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <struct_violation name="image" param="fill_color"/>
            </if>
            <then>      <log>fill_color is too short</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>origin</name>                             <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>origin or region is NULL</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>origin</name>                             <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>      <log>origin or region is too short</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>some region array element is 0</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0.
                If image is a 1D image array object, origin[2] must be 0.
                If image is a 2D image object, region[2] must be 1.
                If image is a 1D image array object, region[2] must be 1. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>origin[2]</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>wrong origin or region values for 2D image or 1D image array</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0.
                If image is a 1D image or 1D image buffer object, region[1] and region[2] must be 1. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal>  <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>origin[1]</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>origin[2]</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[1]</name>                      <literal>1</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
               </and>
            </if>
            <then>      <log>wrong origin or region values for 1D image or 1D image buffer</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being filled specified by origin and region is out of bounds for 3D image</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being filled specified by origin and region is out of bounds for 2D image array</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being filled specified by origin and region is out of bounds for 2D image</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being filled specified by origin and region is out of bounds for 1D image array</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="image" property="CL_IMAGE_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being filled specified by origin and region is out of bounds for 1D image</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="image" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being filled specified by origin and region is out of bounds for 1D image buffer</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_DEPTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, depth) for 3D image are not supported by device associated with queue</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, array size) for 2D image array are not supported by device associated with queue</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height) for 2D image are not supported by device associated with queue</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, array size) for 1D image array are not supported by device associated with queue</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image are not supported by device associated with queue</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image buffer are not supported by device associated with queue</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <literal>CL_FALSE</literal>                         <query object="command_queue" property="CL_DEVICE_IMAGE_SUPPORT"/>
                </eq>
            </if>
            <then>      <log>the device associated with command_queue does not support images</log>
                <name>clEnqueueFillImage</name>                         <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <struct_violation name="image" param="command_queue"/>
            </if>
            <then>      <log>image format (image channel order and data type) for image are not supported by device associated with queue</log>
                <name>clEnqueueFillImage</name>                         <value>CL_IMAGE_FORMAT_NOT_SUPPORTED</value>
            </then>
        </command>

    <!-- 5.3.5 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueCopyImageToBuffer</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>src_image</name></param>
            <param><type>cl_mem</type>                                  <name>dst_buffer</name></param>
            <param>const <type>size_t</type>*                           <name>src_origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>                                  <name>dst_offset</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="src_image"/>
            </if>
            <then>      <log>src_image is not a valid mem object</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>src_image is not a valid image object</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="dst_buffer"/>
            </if>
            <then>      <log>dst_buffer is not a valid mem object</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="dst_buffer" type="CL_MEM_OBJECT_BUFFER"/>
            </if>
            <then>      <log>dst_buffer is not a valid buffer object</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <not>
                        <object_is_invalid name="src_image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    </not>
                    <eq>
                        <name>dst_buffer</name>                         <query object="src_image" property="CL_MEM_ASSOCIATED_MEMOBJECT"/>
                    </eq>
                </and>
            </if>
            <then>      <log>src_image is a 1D image buffer object created from dst_buffer</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="src_image"/>
            </if>
            <then>      <log>context associated with command_queue and src_image are not the same</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="dst_buffer"/>
            </if>
            <then>      <log>context associated with command_queue and dst_buffer are not the same</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>src_origin</name>                         <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>src_origin or region is NULL</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>src_origin</name>                         <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>      <log>src_origin or region is too short</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>some region array element is 0</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0.
                If image is a 1D image array object, origin[2] must be 0. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="src_image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>src_origin[2]</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>wrong src_origin or region values for 2D image or 1D image array src_image</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="src_image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>src_origin[1]</name>                  <literal>0</literal>
                        </neq>
                        <neq>
                            <name>src_origin[2]</name>                  <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[1]</name>                      <literal>1</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
               </and>
            </if>
            <then>      <log>wrong src_origin or region values for 1D image or 1D image buffer src_image</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>src_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>src_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>src_origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by src_origin and region is out of bounds for 3D image src_image</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>src_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>src_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>src_origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by src_origin and region is out of bounds for 2D image array src_image</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>src_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>src_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by src_origin and region is out of bounds for 2D image src_image</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>src_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>src_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="src_image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by src_origin and region is out of bounds for 1D image array src_image</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>src_origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="src_image" property="CL_IMAGE_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being read specified by src_origin and region is out of bounds for 1D image src_image</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>src_origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="src_image" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being read specified by src_origin and region is out of bounds for 1D image buffer src_image</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <gt>
                    <add>
                        <mult>
                            <query object="src_image" property="CL_IMAGE_ELEMENT_SIZE"/>
                            <name>region[0]</name>
                            <name>region[1]</name>
                            <name>region[2]</name>
                        </mult>
                        <name>dst_offset</name>
                    </add>                                              <query object="dst_buffer" property="CL_MEM_SIZE"/>
                </gt>
            </if>
            <then>      <log>the region specified by dst_offset and dst_offset + dst_cb is out of bounds for dst_buffer</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_DEPTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, depth) for 3D image src_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, array size) for 2D image array src_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height) for 2D image src_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="src_image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, array size) for 1D image array src_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="src_image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image src_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="src_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="src_image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image buffer src_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <neq>
                        <mod>
                            <query object="dst_buffer" property="CL_MEM_OFFSET"/>
                            <query object="command_queue" property="CL_DEVICE_MEM_BASE_ADDR_ALIGN"/>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>dst_buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_MISALIGNED_SUB_BUFFER_OFFSET</value>
            </then>
            <if>
                <eq>
                    <literal>CL_FALSE</literal>                         <query object="command_queue" property="CL_DEVICE_IMAGE_SUPPORT"/>
                </eq>
            </if>
            <then>      <log>the device associated with command_queue does not support images</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <struct_violation name="src_image" param="command_queue"/>
            </if>
            <then>      <log>image format (image channel order and data type) for src_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyImageToBuffer</name>                 <value>CL_IMAGE_FORMAT_NOT_SUPPORTED</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueCopyBufferToImage</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>src_buffer</name></param>
            <param><type>cl_mem</type>                                  <name>dst_image</name></param>
            <param><type>size_t</type>                                  <name>src_offset</name></param>
            <param>const <type>size_t</type>*                           <name>dst_origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="src_buffer"/>
            </if>
            <then>      <log>src_buffer is not a valid mem object</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="src_buffer" type="CL_MEM_OBJECT_BUFFER"/>
            </if>
            <then>      <log>src_buffer is not a valid buffer object</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="dst_image"/>
            </if>
            <then>      <log>dst_image is not a valid mem object</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>dst_image is not a valid image object</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <not>
                        <object_is_invalid name="dst_image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    </not>
                    <eq>
                        <name>src_buffer</name>                         <query object="dst_image" property="CL_MEM_ASSOCIATED_MEMOBJECT"/>
                    </eq>
                </and>
            </if>
            <then>      <log>dst_image is a 1D image buffer object created from src_buffer</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="src_buffer"/>
            </if>
            <then>      <log>context associated with command_queue and src_buffer are not the same</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="dst_image"/>
            </if>
            <then>      <log>context associated with command_queue and dst_image are not the same</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>dst_origin</name>                         <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>dst_origin or region is NULL</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>dst_origin</name>                         <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>      <log>dst_origin or region is too short</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>some region array element is 0</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0.
                If image is a 1D image array object, origin[2] must be 0. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="dst_image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>dst_origin[2]</name>                  <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>wrong dst_origin or region values for 2D image or 1D image array dst_image</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="dst_image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>dst_origin[1]</name>                  <literal>0</literal>
                        </neq>
                        <neq>
                            <name>dst_origin[2]</name>                  <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[1]</name>                      <literal>1</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
               </and> 
            </if>
            <then>      <log>wrong dst_origin or region values for 1D image or 1D image buffer dst_image</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>dst_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>dst_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>dst_origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being written specified by dst_origin and region is out of bounds for 3D image dst_image</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>dst_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>dst_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>dst_origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by dst_origin and region is out of bounds for 2D image array dst_image</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>dst_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>dst_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by dst_origin and region is out of bounds for 2D image dst_image</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>dst_origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>dst_origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="dst_image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being read specified by dst_origin and region is out of bounds for 1D image array dst_image</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>dst_origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being read specified by dst_origin and region is out of bounds for 1D image dst_image</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>dst_origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="dst_image" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being read specified by dst_origin and region is out of bounds for 1D image buffer dst_image</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <gt>
                    <add>
                        <mult>
                            <query object="dst_image" property="CL_IMAGE_ELEMENT_SIZE"/>
                            <name>region[0]</name>
                            <name>region[1]</name>
                            <name>region[2]</name>
                        </mult>
                        <name>src_offset</name>
                    </add>                                              <query object="src_buffer" property="CL_MEM_SIZE"/>
                </gt>
            </if>
            <then>      <log>the region specified by src_offset and src_offset + src_cb is out of bounds for src_buffer</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_DEPTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, depth) for 3D image dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, array size) for 2D image array dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height) for 2D image dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="dst_image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, array size) for 1D image array dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="dst_image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="dst_image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image buffer dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <and>
                    <from version="1.1"/>
                    <neq>
                        <mod>
                            <query object="src_buffer" property="CL_MEM_OFFSET"/>
                            <query object="command_queue" property="CL_DEVICE_MEM_BASE_ADDR_ALIGN"/>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>src_buffer is a sub-buffer object and offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_MISALIGNED_SUB_BUFFER_OFFSET</value>
            </then>
            <if>
                <eq>
                    <literal>CL_FALSE</literal>                         <query object="command_queue" property="CL_DEVICE_IMAGE_SUPPORT"/>
                </eq>
            </if>
            <then>      <log>the device associated with command_queue does not support images</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <struct_violation name="dst_image" param="command_queue"/>
            </if>
            <then>      <log>image format (image channel order and data type) for dst_image are not supported by device associated with queue</log>
                <name>clEnqueueCopyBufferToImage</name>                 <value>CL_IMAGE_FORMAT_NOT_SUPPORTED</value>
            </then>
        </command>

    <!-- 5.3.6 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>void</type>*                                   <name>clEnqueueMapImage</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>image</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_map</name></param>
            <param><type>cl_map_flags</type>                            <name>map_flags</name></param>
            <param>const <type>size_t</type>*                           <name>origin</name></param>
            <param>const <type>size_t</type>*                           <name>region</name></param>
            <param><type>size_t</type>*                                 <name>image_row_pitch</name></param>
            <param><type>size_t</type>*                                 <name>image_slice_pitch</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="image"/>
            </if>
            <then>      <log>image is not a valid mem object</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>image is not a valid image object</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="image"/>
            </if>
            <then>      <log>context associated with command_queue and image are not the same</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <bitfield_violation name="map_flags"/>
                    <eq>
                        <name>map_flags</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>values specified in map_flags are not valid</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <name>map_flags</name>                          <literal>CL_MAP_WRITE_INVALIDATE_REGION</literal>
                    </bit_and>
                    <or>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_READ</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>values specified in map_flags are not compatible</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>origin</name>                             <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>region</name>                             <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>origin or region is NULL</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <or>
                    <array_len_ls>
                        <name>origin</name>                             <literal>3</literal>
                    </array_len_ls>
                    <array_len_ls>
                        <name>region</name>                             <literal>3</literal>
                    </array_len_ls>
                </or>
            </if>
            <then>      <log>origin or region is too short</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>region[0]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[1]</name>                          <literal>0</literal>
                    </eq>
                    <eq>
                        <name>region[2]</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>some region array element is 0</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 2D image object, origin[2] must be 0.
                If image is a 1D image array object, origin[2] must be 0. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE2D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>origin[2]</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>wrong origin or region values for 2D image or 1D image array</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- If image is a 1D image or 1D image buffer object, origin[1] and origin[2] must be 0. -->
                <and>
                    <or>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D</literal>    <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                        <eq>
                            <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal>  <query object="image" property="CL_MEM_TYPE"/>
                        </eq>
                    </or>
                    <or>
                        <neq>
                            <name>origin[1]</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>origin[2]</name>                      <literal>0</literal>
                        </neq>
                        <neq>
                            <name>region[1]</name>                      <literal>1</literal>
                        </neq>
                        <neq>
                            <name>region[2]</name>                      <literal>1</literal>
                        </neq>
                    </or>
               </and>
            </if>
            <then>      <log>wrong origin or region values for 1D image or 1D image buffer</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being mapped specified by origin and region is out of bounds for 3D image</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[2]</name>
                                <name>region[2]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being mapped specified by origin and region is out of bounds for 2D image array</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being mapped specified by origin and region is out of bounds for 2D image</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <add>
                                <name>origin[0]</name>
                                <name>region[0]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_WIDTH"/>
                        </gt>
                        <gt>
                            <add>
                                <name>origin[1]</name>
                                <name>region[1]</name>
                            </add>                                      <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>the region being mapped specified by origin and region is out of bounds for 1D image array</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="image" property="CL_IMAGE_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being mapped specified by origin and region is out of bounds for 1D image</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <add>
                            <name>origin[0]</name>
                            <name>region[0]</name>
                        </add>                                          <query object="image" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>the region being mapped specified by origin and region is out of bounds for 1D image buffer</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE3D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_DEPTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE3D_MAX_DEPTH"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, depth) for 3D image are not supported by device associated with queue</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height, array size) for 2D image array are not supported by device associated with queue</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE2D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_HEIGHT"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_HEIGHT"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, height) for 2D image are not supported by device associated with queue</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_ARRAY</literal>  <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <or>
                        <gt>
                            <query object="image" property="CL_IMAGE_WIDTH"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                        </gt>
                        <gt>
                            <query object="image" property="CL_IMAGE_ARRAY_SIZE"/>
                            <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_ARRAY_SIZE"/>
                        </gt>
                    </or>
                </and>
            </if>
            <then>      <log>image dimensions (image width, array size) for 1D image array are not supported by device associated with queue</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D</literal>        <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE2D_MAX_WIDTH"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image are not supported by device associated with queue</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <literal>CL_MEM_OBJECT_IMAGE1D_BUFFER</literal> <query object="image" property="CL_MEM_TYPE"/>
                    </eq>
                    <gt>
                        <query object="image" property="CL_IMAGE_WIDTH"/>
                        <query object="command_queue" property="CL_DEVICE_IMAGE_MAX_BUFFER_SIZE"/>
                    </gt>
                </and>
            </if>
            <then>      <log>image dimensions (image width) for 1D image buffer are not supported by device associated with queue</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_IMAGE_SIZE</value>
            </then>
            <if>
                <eq>
                    <name>image_row_pitch</name>                        <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>image_row_pitch is NULL</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <not>
                        <and>
                            <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE3D"/>
                            <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                            <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                        </and>
                    </not>
                    <eq>
                        <name>image_slice_pitch</name>                  <literal>NULL</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>image is a 3D image, 1D or 2D image array object and image_slice_pitch is NULL</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <literal>CL_FALSE</literal>                         <query object="command_queue" property="CL_DEVICE_IMAGE_SUPPORT"/>
                </eq>
            </if>
            <then>      <log>the device associated with command_queue does not support images</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <struct_violation name="image" param="command_queue"/>
            </if>
            <then>      <log>image format (image channel order and data type) for image are not supported by device associated with queue</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_IMAGE_FORMAT_NOT_SUPPORTED</value>
            </then>
            <if>
                <and>
                    <or>
                        <bit_and>
                            <literal>CL_MEM_HOST_WRITE_ONLY</literal>   <query object="image" property="CL_MEM_FLAGS"/>
                        </bit_and>
                        <bit_and>
                            <literal>CL_MEM_HOST_NO_ACCESS</literal>    <query object="image" property="CL_MEM_FLAGS"/>
                        </bit_and>
                    </or>
                    <bit_and>
                        <name>map_flags</name>                          <literal>CL_MAP_READ</literal>
                    </bit_and>
                </and>
            </if>
            <then>      <log>image has been created with CL_MEM_HOST_WRITE_ONLY or CL_MEM_HOST_NO_ACCESS and CL_MAP_READ is set in map_flags</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <and>
                    <or>
                        <bit_and>
                            <literal>CL_MEM_HOST_READ_ONLY</literal>    <query object="image" property="CL_MEM_FLAGS"/>
                        </bit_and>
                        <bit_and>
                            <literal>CL_MEM_HOST_NO_ACCESS</literal>    <query object="image" property="CL_MEM_FLAGS"/>
                        </bit_and>
                    </or>
                    <or>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_WRITE_INVALIDATE_REGION</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>image has been created with CL_MEM_HOST_READ_ONLY or CL_MEM_HOST_NO_ACCESS and CL_MAP_WRITE or CL_MAP_WRITE_INVALIDATE_REGION is set in map_flags</log>
                <name>clEnqueueMapImage</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <!-- not possible without state to store mapped regions
            CL_INVALID_OPERATION if mapping would lead to overlapping regions being mapped for writing -->
        </command>

    <!-- 5.3.7 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetImageInfo</name></proto>
            <param><type>cl_mem</type>                                  <name>image</name></param>
            <param><type>cl_image_info</type>                           <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="image"/>
            </if>
            <then>      <log>image is not a valid mem object</log>
                <name>clGetImageInfo</name>                             <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <and>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE3D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE2D_ARRAY"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_BUFFER"/>
                    <object_is_invalid name="image" type="CL_MEM_OBJECT_IMAGE1D_ARRAY"/>
                </and>
            </if>
            <then>      <log>image is not a valid image object</log>
                <name>clGetImageInfo</name>                             <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetImageInfo</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetImageInfo</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetImageInfo</name>                             <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.4.1 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>cl_mem</type>                                  <name>clCreatePipe</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_mem_flags</type>                            <name>flags</name></param>
            <param><type>cl_uint</type>                                 <name>pipe_packet_size</name></param>
            <param><type>cl_uint</type>                                 <name>pipe_max_packets</name></param>
            <param>const <type>cl_pipe_properties</type>*               <name>properties</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreatePipe</name>                               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <for_all in="context" query="CL_DEVICE_MAX_PIPE_ARGS">
                    <eq>
                        <name>query</name>                              <literal>0</literal>
                    </eq>
                </for_all>
            </if>
            <then>      <log>no devices in context support pipes</log>
                <name>clCreatePipe</name>                               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <not>
                    <or>
                        <eq>
                            <name>flags</name>                          <literal>0</literal>
                        </eq>
                        <eq>
                            <name>flags</name>                          <literal>CL_MEM_READ_WRITE</literal>
                        </eq>
                        <eq>
                            <name>flags</name>                          <literal>CL_MEM_HOST_NO_ACCESS</literal>
                        </eq>
                        <eq>
                            <name>flags</name>                          <add>
                                                                            <literal>CL_MEM_READ_WRITE</literal>
                                                                            <literal>CL_MEM_HOST_NO_ACCESS</literal>
                                                                        </add>
                        </eq>
                    </or>
                </not>
            </if>
            <then>      <log>values specified in flags are not valid for pipe</log>
                <name>clCreatePipe</name>                               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- can be changed in the future-->
                <neq>
                    <name>properties</name>                             <literal>NULL</literal>
                </neq>
            </if>
            <then>      <log>properties is not NULL</log>
                <name>clCreatePipe</name>                               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>pipe_packet_size</name>                   <literal>0</literal>
                    </eq>
                    <eq>
                        <name>pipe_max_packets</name>                   <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>pipe_packet_size is 0 or pipe_max_packets is 0</log>
                <name>clCreatePipe</name>                               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PIPE_SIZE</value>
            </then>
            <if>
                <for_all in="context" query="CL_DEVICE_PIPE_MAX_PACKET_SIZE">
                    <gt>
                        <name>pipe_packet_size</name>                   <name>query</name>
                    </gt>
                </for_all>
            </if>
            <then>      <log>the pipe_packet_size exceeds CL_DEVICE_PIPE_MAX_PACKET_SIZE value for all devices in context</log>
                <name>clCreatePipe</name>                               <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PIPE_SIZE</value>
            </then>
        </command>

    <!-- 5.4.2 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetPipeInfo</name></proto>
            <param><type>cl_mem</type>                                  <name>pipe</name></param>
            <param><type>cl_pipe_info</type>                            <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="pipe"/>
            </if>
            <then>      <log>pipe is not a valid mem object</log>
                <name>clGetPipeInfo</name>                              <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <object_is_invalid name="pipe" type="CL_MEM_OBJECT_PIPE"/>
            </if>
            <then>      <log>pipe is not a valid pipe object</log>
                <name>clGetPipeInfo</name>                              <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetPipeInfo</name>                              <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetPipeInfo</name>                              <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetPipeInfo</name>                              <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.5.1 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clRetainMemObject</name></proto>
            <param><type>cl_mem</type>                                  <name>memobj</name></param>

            <if>
                <object_is_invalid name="memobj"/>
            </if>
            <then>      <log>memobj is not a valid memory object</log>
                <name>clRetainMemObject</name>                          <value>CL_INVALID_MEM_OBJECT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clReleaseMemObject</name></proto>
            <param><type>cl_mem</type>                                  <name>memobj</name></param>

            <if>
                <object_is_invalid name="memobj"/>
            </if>
            <then>      <log>memobj is not a valid memory object</log>
                <name>clReleaseMemObject</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clSetMemObjectDestructorCallback</name></proto>
            <param><type>cl_mem</type>                                  <name>memobj</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(cl_mem memobj, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>

            <if>
                <object_is_invalid name="memobj"/>
            </if>
            <then>      <log>memobj is not a valid memory object</log>
                <name>clSetMemObjectDestructorCallback</name>           <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <eq>
                    <name>pfn_notify</name>                             <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>pfn_notify is NULL</log>
                <name>clSetMemObjectDestructorCallback</name>           <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.5.2 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueUnmapMemObject</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_mem</type>                                  <name>memobj</name></param>
            <param><type>void</type>*                                   <name>mapped_ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="memobj"/>
            </if>
            <then>      <log>memobj is not a valid memory object</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <not>
                    <object_is_invalid name="memobj" type="CL_MEM_OBJECT_PIPE"/>
                </not>
            </if>
            <then>      <log>memobj is a pipe object</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <!-- not possible without state to store mapped pointers
            CL_INVALID_VALUE if mapped_ptr is not a valid pointer returned by clEnqueueMapBuffer or clEnqueueMapImage for memobj -->
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="memobj"/>
            </if>
            <then>      <log>context associated with command_queue and memobj are not the same</log>
                <name>clEnqueueUnmapMemObject</name>                    <value>CL_INVALID_CONTEXT</value>
            </then>
        </command>

    <!-- 5.5.4 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueMigrateMemObjects</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_uint</type>                                 <name>num_mem_objects</name></param>
            <param>const <type>cl_mem</type>*                           <name>mem_objects</name></param>
            <param><type>cl_mem_migration_flags</type>                  <name>flags</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>num_mem_objects</name>                    <literal>0</literal>
                    </eq>
                    <eq>
                        <name>mem_objects</name>                        <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>num_mem_objects is zero or if mem_objects is NULL</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>mem_objects</name>                            <name>num_mem_objects</name>
                </array_len_ls>
            </if>
            <then>      <log>mem_objects is too short</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <any_invalid array="mem_objects" elements="num_mem_objects"/>
            </if>
            <then>      <log>some of the memory objects in mem_objects is not a valid memory object</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <any_object_not_in array="mem_objects" elements="num_mem_objects" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and memory objects in mem_objects are not the same</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <bitfield_violation name="flags"/> <!-- 0 is valid here-->
            </if>
            <then>      <log>flags is not 0 and is not any of the valid values</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueMigrateMemObjects</name>                 <value>CL_INVALID_CONTEXT</value>
            </then>
        </command>

    <!-- 5.5.5 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetMemObjectInfo</name></proto>
            <param><type>cl_mem</type>                                  <name>memobj</name></param>
            <param><type>cl_mem_info</type>                             <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="memobj"/>
            </if>
            <then>      <log>memobj is not a valid memory object</log>
                <name>clGetMemObjectInfo</name>                         <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetMemObjectInfo</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetMemObjectInfo</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetMemObjectInfo</name>                         <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.6.1 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>void</type>*                                   <name>clSVMAlloc</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_svm_mem_flags</type>                        <name>flags</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>alignment</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
            <if>
                <for_all in="context" query="CL_DEVICE_SVM_CAPABILITIES">
                    <eq>
                        <name>query</name>                              <literal>0</literal>
                    </eq>
                </for_all>
            </if>
            <then>      <log>no devices in context support SVM</log>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
            <if> <!-- spec is not clear whether 0 is a valid value-->
                <or>
                    <bitfield_violation name="flags"/>
                    <eq>
                        <name>flags</name>                              <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>values specified in flags are not valid</log>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
            <if>
                <mutex_violation>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_READ_WRITE</literal>
                    </bit_and>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_WRITE_ONLY</literal>
                    </bit_and>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_READ_ONLY</literal>
                    </bit_and>
                </mutex_violation>
            </if>
            <then>      <log>read/write flags are not compatible</log>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_SVM_ATOMICS</literal>
                    </bit_and>
                    <not>
                        <bit_and>
                            <name>flags</name>                          <literal>CL_MEM_SVM_FINE_GRAIN_BUFFER</literal>
                        </bit_and>
                    </not>
                </and>
            </if>
            <then>      <log>values specified in flags are not compatible: CL_MEM_SVM_ATOMICS is valid only if CL_MEM_SVM_FINE_GRAIN_BUFFER is specified</log>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_SVM_FINE_GRAIN_BUFFER</literal>
                    </bit_and>
                    <for_any in="context" query="CL_DEVICE_SVM_CAPABILITIES">
                        <not>
                            <bit_and>
                                <name>query</name>                      <literal>CL_MEM_SVM_FINE_GRAIN_BUFFER</literal>
                            </bit_and>
                        </not>
                    </for_any>
                </and>
            </if>
            <then>      <log>CL_MEM_SVM_FINE_GRAIN_BUFFER is specified in flags but not supported by at least one device in context</log>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <name>flags</name>                              <literal>CL_MEM_SVM_ATOMICS</literal>
                    </bit_and>
                    <for_any in="context" query="CL_DEVICE_SVM_CAPABILITIES">
                        <not>
                            <bit_and>
                                <name>query</name>                      <literal>CL_MEM_SVM_ATOMICS</literal>
                            </bit_and>
                        </not>
                    </for_any>
                </and>
            </if>
            <then>      <log>CL_MEM_SVM_ATOMICS is specified in flags but not supported by at least one device in context</log>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
            <if>
                <eq>
                    <name>size</name>                                   <literal>0</literal>
                </eq>
            </if>
            <then>      <log>size is 0</log>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
            <if>
                <for_any in="context" query="CL_DEVICE_MAX_MEM_ALLOC_SIZE">
                    <gt>
                        <name>size</name>                               <name>query</name>
                    </gt>
                </for_any>
            </if>
            <then>      <log>size is &gt; CL_DEVICE_MAX_MEM_ALLOC_SIZE value for some device in context</log>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
            <if> <!-- alignment is the minimum alignment in bytes that is required for the newly created buffers memory region. It must be a power of two up to the largest data type supported by the OpenCL device. For the full profile, the largest data type is long16. For the embedded profile, it is long16 if the device supports 64-bit integers; otherwise it is int16. If alignment is 0, a default alignment will be used that is equal to the size of largest data type supported by the OpenCL implementation-->
                <and>
                    <neq>
                        <name>alignment</name>                          <literal>0</literal>
                    </neq>
                    <neq>
                        <name>alignment</name>                          <literal>1</literal>
                    </neq>
                    <neq>
                        <name>alignment</name>                          <literal>2</literal>
                    </neq>
                    <neq>
                        <name>alignment</name>                          <literal>4</literal>
                    </neq>
                    <neq>
                        <name>alignment</name>                          <literal>8</literal>
                    </neq>
                    <neq>
                        <name>alignment</name>                          <literal>16</literal>
                    </neq>
                    <neq>
                        <name>alignment</name>                          <literal>32</literal>
                    </neq>
                    <neq>
                        <name>alignment</name>                          <literal>64</literal>
                    </neq>
                    <neq> <!-- this can still provide fail for embedded devices, but tested further -->
                        <name>alignment</name>                          <literal>128</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>alignment is invalid</log>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
            <if>
                <for_any in="context" query="CL_DEVICE_MEM_BASE_ADDR_ALIGN">
                    <ls>
                        <name>query</name>                              <name>alignment</name>
                    </ls>
                </for_any>
            </if>
            <then>      <log>the OpenCL implementation cannot support the specified alignment for at least one device in context</log>
                <name>clSVMAlloc</name>                                 <value>NULL</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>void</type>                                    <name>clSVMFree</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>void</type>*                                   <name>svm_pointer</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
            </then>
            <if>
                <for_all in="context" query="CL_DEVICE_SVM_CAPABILITIES">
                    <eq>
                        <name>query</name>                              <literal>0</literal>
                    </eq>
                </for_all>
            </if>
            <then>      <log>no devices in context support SVM</log>
            </then>
            <!-- with state can check that svm_pointer is the value returned by a call to clSVMAlloc -->
            <!-- and that context is a valid OpenCL context used to create the SVM buffer -->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueSVMFree</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_uint</type>                                 <name>num_svm_pointers</name></param>
            <param><type>void</type>*                                   <name>svm_pointers</name>[]</param>
            <param>void (CL_CALLBACK*                                   <name>pfn_free_func</name>)(cl_command_queue queue, cl_uint num_svm_pointers, void* svm_pointers[], void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <eq>
                    <literal>0</literal>                                <query object="command_queue" property="CL_DEVICE_SVM_CAPABILITIES"/>
                </eq>
            </if>
            <then>      <log>the device associated with command queue does not support SVM</log>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>num_svm_pointers</name>                   <literal>0</literal>
                    </eq>
                    <neq>
                        <name>svm_pointers</name>                       <literal>NULL</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>num_svm_pointers is 0 and svm_pointers is non-NULL</log>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>num_svm_pointers</name>                   <literal>0</literal>
                    </neq>
                    <eq>
                        <name>svm_pointers</name>                       <literal>NULL</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>svm_pointers is NULL and num_svm_pointers is not 0</log>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>svm_pointers</name>                       <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>svm_pointers</name>                       <name>num_svm_pointers</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>svm_pointers is too short</log>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <!-- with state can check that each pointer in svm_pointers that was allocated using clSVMAlloc has been allocated from the same context from which command_queue was created -->
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if> <!-- not covered by standard-->
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueSVMFree</name>                           <value>CL_INVALID_CONTEXT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueSVMMemcpy</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_copy</name></param>
            <param><type>void</type>*                                   <name>dst_ptr</name></param>
            <param>const <type>void</type>*                             <name>src_ptr</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueSVMMemcpy</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueSVMMemcpy</name>                         <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <eq>
                    <literal>0</literal>                                <query object="command_queue" property="CL_DEVICE_SVM_CAPABILITIES"/>
                </eq>
            </if>
            <then>      <log>the device associated with command queue does not support SVM</log>
                <name>clEnqueueSVMMemcpy</name>                         <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueSVMMemcpy</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueSVMMemcpy</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueSVMMemcpy</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueSVMMemcpy</name>                         <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueSVMMemcpy</name>                         <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>dst_ptr</name>                            <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>src_ptr</name>                            <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>dst_ptr or src_ptr is NULL</log>
                <name>clEnqueueSVMMemcpy</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <check_copy_overlap param="dst_ptr, src_ptr, size"/>
            </if>
            <then>      <log>the values specified for dst_ptr, src_ptr and size result in an overlapping copy</log>
                <name>clEnqueueSVMMemcpy</name>                         <value>CL_MEM_COPY_OVERLAP</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueSVMMemFill</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>void</type>*                                   <name>svm_ptr</name></param>
            <param>const <type>void</type>*                             <name>pattern</name></param>
            <param><type>size_t</type>                                  <name>pattern_size</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <eq>
                    <literal>0</literal>                                <query object="command_queue" property="CL_DEVICE_SVM_CAPABILITIES"/>
                </eq>
            </if>
            <then>      <log>the device associated with command queue does not support SVM</log>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <name>svm_ptr</name>                                <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>svm_ptr is NULL</log>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>pattern</name>                                <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>pattern is NULL</log>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>pattern_size</name>                       <literal>1</literal>
                    </neq>
                    <neq>
                        <name>pattern_size</name>                       <literal>2</literal>
                    </neq>
                    <neq>
                        <name>pattern_size</name>                       <literal>4</literal>
                    </neq>
                    <neq>
                        <name>pattern_size</name>                       <literal>8</literal>
                    </neq>
                    <neq>
                        <name>pattern_size</name>                       <literal>16</literal>
                    </neq>
                    <neq>
                        <name>pattern_size</name>                       <literal>32</literal>
                    </neq>
                    <neq>
                        <name>pattern_size</name>                       <literal>64</literal>
                    </neq>
                    <neq>
                        <name>pattern_size</name>                       <literal>128</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>pattern_size is not one of {1, 2, 4, 8, 16, 32, 64, 128}</log>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <neq>
                    <mod>
                        <name>size</name>
                        <name>pattern_size</name>
                    </mod>                                              <literal>0</literal>
                </neq>
            </if>
            <then>      <log>size is not a multiple of pattern_size</log>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <not_aligned pointer="svm_ptr" align="pattern_size"/>
            </if>
            <then>      <log>svm_ptr is not aligned to pattern_size bytes</log>
                <name>clEnqueueSVMMemFill</name>                        <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueSVMMap</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_bool</type>                                 <name>blocking_map</name></param>
            <param><type>cl_map_flags</type>                            <name>map_flags</name></param>
            <param><type>void</type>*                                   <name>svm_ptr</name></param>
            <param><type>size_t</type>                                  <name>size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <eq>
                    <literal>0</literal>                                <query object="command_queue" property="CL_DEVICE_SVM_CAPABILITIES"/>
                </eq>
            </if>
            <then>      <log>the device associated with command queue does not support SVM</log>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <name>svm_ptr</name>                                <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>svm_ptr is NULL</log>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>size</name>                                   <literal>0</literal>
                </eq>
            </if>
            <then>      <log>size is 0</log>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <bitfield_violation name="map_flags"/>
                    <eq>
                        <name>map_flags</name>                          <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>values specified in map_flags are not valid</log>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <bit_and>
                        <name>map_flags</name>                          <literal>CL_MAP_WRITE_INVALIDATE_REGION</literal>
                    </bit_and>
                    <or>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_WRITE</literal>
                        </bit_and>
                        <bit_and>
                            <name>map_flags</name>                      <literal>CL_MAP_READ</literal>
                        </bit_and>
                    </or>
                </and>
            </if>
            <then>      <log>values specified in map_flags are not compatible</log>
                <name>clEnqueueSVMMap</name>                            <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueSVMUnmap</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>void</type>*                                   <name>svm_ptr</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueSVMUnmap</name>                          <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueSVMUnmap</name>                          <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <eq>
                    <literal>0</literal>                                <query object="command_queue" property="CL_DEVICE_SVM_CAPABILITIES"/>
                </eq>
            </if>
            <then>      <log>the device associated with command queue does not support SVM</log>
                <name>clEnqueueSVMUnmap</name>                          <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueSVMUnmap</name>                          <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueSVMUnmap</name>                          <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueSVMUnmap</name>                          <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueSVMUnmap</name>                          <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueSVMUnmap</name>                          <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <name>svm_ptr</name>                                <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>svm_ptr is NULL</log>
                <name>clEnqueueSVMUnmap</name>                          <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_1"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueSVMMigrateMem</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_uint</type>                                 <name>num_svm_pointers</name></param>
            <param>const <type>void</type>**                            <name>svm_pointers</name></param>
            <param>const <type>size_t</type>*                           <name>sizes</name></param>
            <param><type>cl_mem_migration_flags</type>                  <name>flags</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueSVMMigrateMem</name>                     <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueSVMMigrateMem</name>                     <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <eq>
                    <literal>0</literal>                                <query object="command_queue" property="CL_DEVICE_SVM_CAPABILITIES"/>
                </eq>
            </if>
            <then>      <log>the device associated with command queue does not support SVM</log>
                <name>clEnqueueSVMMigrateMem</name>                     <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueSVMMigrateMem</name>                     <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueSVMMigrateMem</name>                     <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueSVMMigrateMem</name>                     <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueSVMMigrateMem</name>                     <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueSVMMigrateMem</name>                     <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>num_svm_pointers</name>                   <literal>0</literal>
                    </eq>
                    <eq>
                        <name>svm_pointers</name>                       <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>num_svm_pointers is zero or svm_pointers is NULL</log>
                <name>clEnqueueSVMMigrateMem</name>                     <value>CL_INVALID_VALUE</value>
            </then>
            <!-- state needed for
            CL_INVALID_VALUE if sizes[i] is non-zero and range [svm_pointers[i], svm_pointers[i]+sizes[i]) is not contained within an existing clSVMAlloc allocation -->
        </command>

    <!-- 5.7.1 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>cl_sampler</type>                              <name>clCreateSamplerWithProperties</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param>const <type>cl_sampler_properties</type>*            <name>sampler_properties</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateSamplerWithProperties</name>              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <list_violation name="sampler_properties"/>
            </if>
            <then>      <log>the property name in sampler_properties is not a supported property name, if the value specified for a supported property name is not valid, or if the same property name is specified more than once</log>
                <name>clCreateSamplerWithProperties</name>              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <for_all in="context" query="CL_DEVICE_IMAGE_SUPPORT">
                    <eq>
                        <literal>CL_FALSE</literal>                     <name>query</name>
                    </eq>
                </for_all>
            </if>
            <then>      <log>there are no devices in context that support images</log>
                <name>clCreateSamplerWithProperties</name>              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_2_DEPRECATED"> <!--DONE-->
            <proto><type>cl_sampler</type>                              <name>clCreateSampler</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_bool</type>                                 <name>normalized_coords</name></param>
            <param><type>cl_addressing_mode</type>                      <name>addressing_mode</name></param>
            <param><type>cl_filter_mode</type>                          <name>filter_mode</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateSampler</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <enum_violation name="addressing_mode"/>
            </if>
            <then>      <log>addressing_mode is not valid</log>
                <name>clCreateSampler</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <enum_violation name="filter_mode"/>
            </if>
            <then>      <log>filter_mode is not valid</log>
                <name>clCreateSampler</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- CL_INVALID_VALUE if a combination of addressing_mode, filter_mode, normalized_coords are not valid - there are no such combinations yet -->
            <if>
                <for_all in="context" query="CL_DEVICE_IMAGE_SUPPORT">
                    <eq>
                        <literal>CL_FALSE</literal>                     <name>query</name>
                    </eq>
                </for_all>
            </if>
            <then>      <log>there are no devices in context that support images</log>
                <name>clCreateSampler</name>                            <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clRetainSampler</name></proto>
            <param><type>cl_sampler</type>                              <name>sampler</name></param>

            <if>
                <object_is_invalid name="sampler"/>
            </if>
            <then>      <log>sampler is not a valid sampler object</log>
                <name>clRetainSampler</name>                            <value>CL_INVALID_SAMPLER</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clReleaseSampler</name></proto>
            <param><type>cl_sampler</type>                              <name>sampler</name></param>

            <if>
                <object_is_invalid name="sampler"/>
            </if>
            <then>      <log>sampler is not a valid sampler object</log>
                <name>clReleaseSampler</name>                           <value>CL_INVALID_SAMPLER</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetSamplerInfo</name></proto>
            <param><type>cl_sampler</type>                              <name>sampler</name></param>
            <param><type>cl_sampler_info</type>                         <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="sampler"/>
            </if>
            <then>      <log>sampler is not a valid sampler object</log>
                <name>clGetSamplerInfo</name>                           <value>CL_INVALID_SAMPLER</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetSamplerInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetSamplerInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetSamplerInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.8.1 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_program</type>                              <name>clCreateProgramWithSource</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_uint</type>                                 <name>count</name></param>
            <param>const <type>char</type>**                            <name>strings</name></param>
            <param>const <type>size_t</type>*                           <name>lengths</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateProgramWithSource</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <eq>
                    <name>count</name>                                  <literal>0</literal>
                </eq>
            </if>
            <then>      <log>count is zero</log>
                <name>clCreateProgramWithSource</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>strings</name>                                <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>strings is NULL</log>
                <name>clCreateProgramWithSource</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <and>
                    <neq>
                        <name>lengths</name>                            <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>lengths</name>                            <name>count</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>lengths is too short</log>
                <name>clCreateProgramWithSource</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>strings</name>                                <name>count</name>
                </array_len_ls>
            </if>
            <then>      <log>strings is too short</log>
                <name>clCreateProgramWithSource</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <any_nullptr array="strings" elements="count"/>
            </if>
            <then>      <log>some entry in strings is NULL</log>
                <name>clCreateProgramWithSource</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_1"> <!--DONE-->
            <proto><type>cl_program</type>                              <name>clCreateProgramWithIL</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param>const <type>void</type>*                             <name>il</name></param>
            <param><type>size_t</type>                                  <name>length</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateProgramWithIL</name>                      <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <for_all in="context" query="CL_DEVICE_IL_VERSION">
                    <eq>
                        <literal>0</literal>                            <name>query</name>
                    </eq>
                </for_all>
            </if>
            <then>      <log>no devices in context support intermediate language programs</log>
                <name>clCreateProgramWithIL</name>                      <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>il</name>                                 <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>length</name>                             <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>il is NULL or if length is zero</log>
                <name>clCreateProgramWithIL</name>                      <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>il</name>                                     <name>length</name>
                </array_len_ls>
            </if>
            <then>      <log>il is too short</log>
                <name>clCreateProgramWithIL</name>                      <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_program</type>                              <name>clCreateProgramWithBinary</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param>const <type>cl_device_id</type>*                     <name>device_list</name></param>
            <param>const <type>size_t</type>*                           <name>lengths</name></param>
            <param>const <type>unsigned char</type>**                   <name>binaries</name></param>
            <param><type>cl_int</type>*                                 <name>binary_status</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>num_devices</name>                        <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>device_list is NULL or num_devices is zero</log>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>device_list</name>                            <name>num_devices</name>
                </array_len_ls>
            </if>
            <then>      <log>device_list is too short</log>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <any_object_not_in array="device_list" elements="num_devices" in="context"/>
            </if>
            <then>      <log>some device in device_list is not in the list of devices associated with context</log>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>lengths</name>                            <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>binaries</name>                           <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>lengths or binaries is NULL</log>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>lengths</name>                                <name>num_devices</name>
                </array_len_ls>
            </if>
            <then>      <log>lengths is too short</log>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>binaries</name>                               <name>num_devices</name>
                </array_len_ls>
            </if>
            <then>      <log>binaries is too short</log>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <and>
                    <neq>
                        <name>binary_status</name>                      <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>binary_status</name>                      <name>num_devices</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>binary_status is too short</log>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <any_zero array="lengths" elements="num_devices"/>
            </if>
            <then>      <log>some entry in lengths is zero</log>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <any_nullptr array="binaries" elements="num_devices"/>
            </if>
            <then>      <log>some entry in binaries is NULL</log>
                <name>clCreateProgramWithBinary</name>                  <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_program</type>                              <name>clCreateProgramWithBuiltInKernels</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param>const <type>cl_device_id</type>*                     <name>device_list</name></param>
            <param>const <type>char</type>*                             <name>kernel_names</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateProgramWithBuiltInKernels</name>          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </eq>
                    <eq>
                        <name>num_devices</name>                        <literal>0</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>device_list is NULL or num_devices is zero</log>
                <name>clCreateProgramWithBuiltInKernels</name>          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>device_list</name>                            <name>num_devices</name>
                </array_len_ls>
            </if>
            <then>      <log>device_list is too short</log>
                <name>clCreateProgramWithBuiltInKernels</name>          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <any_object_not_in array="device_list" elements="num_devices" in="context"/>
            </if>
            <then>      <log>some device in device_list is not in the list of devices associated with context</log>
                <name>clCreateProgramWithBuiltInKernels</name>          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <eq>
                    <name>device_list</name>                            <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>device_list is NULL</log>
                <name>clCreateProgramWithBuiltInKernels</name>          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>num_devices</name>                            <literal>0</literal>
                </eq>
            </if>
            <then>      <log>num_devices is zero</log>
                <name>clCreateProgramWithBuiltInKernels</name>          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>kernel_names</name>                           <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>kernel_names is NULL</log>
                <name>clCreateProgramWithBuiltInKernels</name>          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- intricated but possible
            CL_INVALID_VALUE if kernel_names contains a kernel name that is not supported by any of the devices in device_list. -->
        </command>

    <!-- 5.8.2 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clRetainProgram</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>

            <if>
                <object_is_invalid name="program"/>
            </if>
            <then>      <log>program is not a valid program object</log>
                <name>clRetainProgram</name>                            <value>CL_INVALID_PROGRAM</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clReleaseProgram</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>

            <if>
                <object_is_invalid name="program"/>
            </if>
            <then>      <log>program is not a valid program object</log>
                <name>clReleaseProgram</name>                           <value>CL_INVALID_PROGRAM</value>
            </then>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_2_2_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_2_2_DEPRECATED"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clSetProgramReleaseCallback</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(cl_program program, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>

            <if>
                <object_is_invalid name="program"/>
            </if>
            <then>      <log>program is not a valid program object</log>
                <name>clSetProgramReleaseCallback</name>                <value>CL_INVALID_PROGRAM</value>
            </then>
            <if>
                <eq>
                    <name>pfn_notify</name>                             <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>pfn_notify is NULL</log>
                <name>clSetProgramReleaseCallback</name>                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- not queryable
            CL_INVALID_OPERATION if no devices in the context associated with program support destructors for program scope global variables. -->
        </command>

    <!-- 5.8.3 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_2_2"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clSetProgramSpecializationConstant</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param><type>cl_uint</type>                                 <name>spec_id</name></param>
            <param><type>size_t</type>                                  <name>spec_size</name></param>
            <param>const <type>void</type>*                             <name>spec_value</name></param>

            <if>
                <object_is_invalid name="program"/>
            </if>
            <then>      <log>program is not a valid program object</log>
                <name>clSetProgramSpecializationConstant</name>         <value>CL_INVALID_PROGRAM</value>
            </then>
            <if>
                <eq>
                    <literal>0</literal>                                <query object="program" property="CL_PROGRAM_IL"/>
                </eq>
            </if>
            <then>      <log>program is not a valid program object created from an intermediate language</log>
                <name>clSetProgramSpecializationConstant</name>         <value>CL_INVALID_PROGRAM</value>
            </then>
            <if>
                <for_all in="program" query="CL_DEVICE_IL_VERSION">
                    <eq>
                        <literal>0</literal>                            <name>query</name>
                    </eq>
                </for_all>
            </if>
            <then>      <log>no devices associated with program support intermediate language programs</log>
                <name>clSetProgramSpecializationConstant</name>         <value>CL_INVALID_OPERATION</value>
            </then>
            <if> <!-- standard does not say for_all or for_any -->
                <for_any in="program" query="CL_DEVICE_COMPILER_AVAILABLE">
                    <eq>
                        <literal>CL_FALSE</literal>                     <name>query</name>
                    </eq>
                </for_any>
            </if>
            <then>      <log>program is created with clCreateProgramWithIL and a compiler is not available</log>
                <name>clSetProgramSpecializationConstant</name>         <value>CL_COMPILER_NOT_AVAILABLE</value>
            </then>
            <if>
                <eq>
                    <name>spec_value</name>                             <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>spec_value is NULL</log>
                <name>clSetProgramSpecializationConstant</name>         <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.8.4 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clBuildProgram</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param>const <type>cl_device_id</type>*                     <name>device_list</name></param>
            <param>const <type>char</type>*                             <name>options</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(cl_program program, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>

            <if>
                <object_is_invalid name="program"/>
            </if>
            <then>      <log>program is not a valid program object</log>
                <name>clBuildProgram</name>                             <value>CL_INVALID_PROGRAM</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_devices</name>                        <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>device_list is NULL and num_devices is greater than zero</log>
                <name>clBuildProgram</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_devices</name>                        <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>device_list is not NULL and num_devices is zero</log>
                <name>clBuildProgram</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>pfn_notify</name>                         <literal>NULL</literal>
                    </eq>
                    <neq>
                        <name>user_data</name>                          <literal>NULL</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>pfn_notify is NULL but user_data is not NULL</log>
                <name>clBuildProgram</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <any_object_not_in array="device_list" elements="num_devices" in="program"/>
            </if>
            <then>      <log>some device in device_list is not in the list of devices associated with program</log>
                <name>clBuildProgram</name>                             <value>CL_INVALID_DEVICE</value>
            </then>
            <!-- not queryable, need state
            CL_INVALID_BINARY if program is created with clCreateProgramWithBinary and devices listed in device_list do not have a valid program binary loaded.
            CL_COMPILER_NOT_AVAILABLE if program is created with clCreateProgramWithSource or clCreateProgramWithIL and a compiler is not available
            CL_INVALID_OPERATION if the build of a program executable for any of the devices listed in device_list by a previous call to clBuildProgram for program has not completed.
            CL_INVALID_OPERATION if program was not created with clCreateProgramWithSource, clCreateProgramWithIL or clCreateProgramWithBinary.-->
        </command>

    <!-- 5.8.5 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clCompileProgram</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param>const <type>cl_device_id</type>*                     <name>device_list</name></param>
            <param>const <type>char</type>*                             <name>options</name></param>
            <param><type>cl_uint</type>                                 <name>num_input_headers</name></param>
            <param>const <type>cl_program</type>*                       <name>input_headers</name></param>
            <param>const <type>char</type>**                            <name>header_include_names</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(cl_program program, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>

            <if>
                <object_is_invalid name="program"/>
            </if>
            <then>      <log>program is not a valid program object</log>
                <name>clCompileProgram</name>                           <value>CL_INVALID_PROGRAM</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>num_input_headers</name>                  <literal>0</literal>
                    </eq>
                    <or>
                        <neq>
                            <name>header_include_names</name>           <literal>NULL</literal>
                        </neq>
                        <neq>
                            <name>input_headers</name>                  <literal>NULL</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>num_input_headers is zero and header_include_names or input_headers are not NULL</log>
                <name>clCompileProgram</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>num_input_headers</name>                  <literal>0</literal>
                    </neq>
                    <or>
                        <eq>
                            <name>header_include_names</name>           <literal>NULL</literal>
                        </eq>
                        <eq>
                            <name>input_headers</name>                  <literal>NULL</literal>
                        </eq>
                    </or>
                </and>
            </if>
            <then>      <log>num_input_headers is not zero and header_include_names or input_headers are NULL</log>
                <name>clCompileProgram</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <and>
                    <neq>
                        <name>num_input_headers</name>                  <literal>0</literal>
                    </neq>
                    <or>
                        <array_len_ls>
                            <name>header_include_names</name>           <name>num_input_headers</name>
                        </array_len_ls>
                        <array_len_ls>
                            <name>input_headers</name>                  <name>num_input_headers</name>
                        </array_len_ls>
                    </or>
                </and>
            </if>
            <then>      <log>header_include_names or input_headers is too short</log>
                <name>clCompileProgram</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>device_list</name>                            <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_devices</name>                            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>device_list is NULL and num_devices is greater than zero</log>
                <name>clCompileProgram</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_devices</name>                        <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>device_list is not NULL and num_devices is zero</log>
                <name>clCompileProgram</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <and>
                    <neq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>device_list</name>                        <name>num_devices</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>device_list is too short</log>
                <name>clCompileProgram</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <any_object_not_in array="device_list" elements="num_devices" in="program"/>
            </if>
            <then>      <log>some device in device_list is not in the list of devices associated with program</log>
                <name>clCompileProgram</name>                           <value>CL_INVALID_DEVICE</value>
            </then>
            <if> <!-- standard does not say for_all or for_any -->
                <and>
                    <neq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </neq>
                    <for_any array="device_list" elements="num_devices" query="CL_DEVICE_COMPILER_AVAILABLE">
                        <eq>
                            <literal>CL_FALSE</literal>                 <name>query</name>
                        </eq>
                    </for_any>
                </and>
            </if>
            <then>      <log>a compiler is not available for some device in device_list</log>
                <name>clCompileProgram</name>                           <value>CL_COMPILER_NOT_AVAILABLE</value>
            </then>
            <if> <!-- standard does not say for_all or for_any -->
                <and>
                    <eq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </eq>
                    <for_any in="program" query="CL_DEVICE_COMPILER_AVAILABLE">
                        <eq>
                            <literal>CL_FALSE</literal>                 <name>query</name>
                        </eq>
                    </for_any>
                </and>
            </if>
            <then>      <log>a compiler is not available for some device in program</log>
                <name>clCompileProgram</name>                           <value>CL_COMPILER_NOT_AVAILABLE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>pfn_notify</name>                         <literal>NULL</literal>
                    </eq>
                    <neq>
                        <name>user_data</name>                          <literal>NULL</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>pfn_notify is NULL but user_data is not NULL</log>
                <name>clCompileProgram</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <!-- need state
            CL_INVALID_OPERATION if the compilation or build of a program executable for any of the devices listed in device_list by a previous call to clCompileProgram or clBuildProgram for program has not completed
            CL_INVALID_OPERATION if there are kernel objects attached to program.
            CL_INVALID_OPERATION if program has no source or IL available, i.e. it has not been created with clCreateProgramWithSource or clCreateProgramWithIL. -->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_program</type>                              <name>clLinkProgram</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_uint</type>                                 <name>num_devices</name></param>
            <param>const <type>cl_device_id</type>*                     <name>device_list</name></param>
            <param>const <type>char</type>*                             <name>options</name></param>
            <param><type>cl_uint</type>                                 <name>num_input_programs</name></param>
            <param>const <type>cl_program</type>*                       <name>input_programs</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_notify</name>)(cl_program program, void* user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_devices</name>                        <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>device_list is NULL and num_devices is greater than zero</log>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_devices</name>                        <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>device_list is not NULL and num_devices is zero</log>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <and>
                    <neq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>device_list</name>                        <name>num_devices</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>device_list is too short</log>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- standard does not say for_all or for_any -->
                <and>
                    <neq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </neq>
                    <for_any array="device_list" elements="num_devices" query="CL_DEVICE_LINKER_AVAILABLE">
                        <eq>
                            <literal>CL_FALSE</literal>                 <name>query</name>
                        </eq>
                    </for_any>
                </and>
            </if>
            <then>      <log>a linker is not available for some device in device_list</log>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_COMPILER_NOT_AVAILABLE</value>
            </then>
            <if> <!-- standard does not say for_all or for_any -->
                <and>
                    <eq>
                        <name>device_list</name>                        <literal>NULL</literal>
                    </eq>
                    <for_any in="context" query="CL_DEVICE_LINKER_AVAILABLE">
                        <eq>
                            <literal>CL_FALSE</literal>                 <name>query</name>
                        </eq>
                    </for_any>
                </and>
            </if>
            <then>      <log>a linker is not available for some device in context</log>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_COMPILER_NOT_AVAILABLE</value>
            </then>
            <if>
                <any_object_not_in array="device_list" elements="num_devices" in="context"/>
            </if>
            <then>      <log>some device in device_list is not in the list of devices associated with context</log>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <eq>
                    <name>num_input_programs</name>                     <literal>0</literal>
                </eq>
            </if>
            <then>      <log>num_input_programs is zero</log>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>input_programs</name>                         <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>input_programs is NULL</log>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>input_programs</name>                         <name>num_input_programs</name>
                </array_len_ls>
            </if>
            <then>      <log>input_programs is too short</log>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <any_invalid array="input_programs" elements="num_input_programs"/>
            </if>
            <then>      <log>programs specified in input_programs are not valid program objects</log>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PROGRAM</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>pfn_notify</name>                         <literal>NULL</literal>
                    </eq>
                    <neq>
                        <name>user_data</name>                          <literal>NULL</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>pfn_notify is NULL but user_data is not NULL</log>
                <name>clLinkProgram</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- intricated but possible
            CL_INVALID_OPERATION if the rules for devices containing compiled binaries or libraries as described in input_programs argument above are not followed -->
        </command>

    <!-- 5.8.8 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clUnloadPlatformCompiler</name></proto>
            <param><type>cl_platform_id</type>                          <name>platform</name></param>

            <if>
                <object_is_invalid name="platform"/>
            </if>
            <then>      <log>platform is not a valid platform</log>
                <name>clUnloadPlatformCompiler</name>                   <value>CL_INVALID_PLATFORM</value>
            </then>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_1_DEPRECATED"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clUnloadCompiler</name></proto>
        </command>

    <!-- 5.8.9 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetProgramInfo</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param><type>cl_program_info</type>                         <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="program"/>
            </if>
            <then>      <log>program is a not a valid program object</log>
                <name>clGetProgramInfo</name>                           <value>CL_INVALID_PROGRAM</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetProgramInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetProgramInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetProgramInfo</name>                           <value>CL_INVALID_VALUE</value>
            </then>
            <!-- need state
            CL_INVALID_PROGRAM_EXECUTABLE if param_name is CL_PROGRAM_NUM_KERNELS, CL_PROGRAM_KERNEL_NAMES, CL_PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT, or CL_PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT and a successful program executable has not been built for at least one device in the list of devices associated with program. -->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetProgramBuildInfo</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_program_build_info</type>                   <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="program"/>
            </if>
            <then>      <log>program is a not a valid program object</log>
                <name>clGetProgramBuildInfo</name>                      <value>CL_INVALID_PROGRAM</value>
            </then>
            <if>
                <object_is_invalid name="device"/>
            </if>
            <then>      <log>device is not a valid device</log>
                <name>clGetProgramBuildInfo</name>                      <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <object_not_in object="device" in="program"/>
            </if>
            <then>      <log>device is not in the list of devices associated with program</log>
                <name>clGetProgramBuildInfo</name>                      <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetProgramBuildInfo</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetProgramBuildInfo</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetProgramBuildInfo</name>                      <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.9.1 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_kernel</type>                               <name>clCreateKernel</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param>const <type>char</type>*                             <name>kernel_name</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="program"/>
            </if>
            <then>      <log>program is a not a valid program object</log>
                <name>clCreateKernel</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_PROGRAM</value>
            </then>
            <if>
                <eq>
                    <name>kernel_name</name>                            <literal>NULL</literal>
                </eq>
            </if>
            <then>
                <name>clCreateKernel</name>                             <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_VALUE</value>
            </then>
            <!-- intricate but possible
            CL_INVALID_PROGRAM_EXECUTABLE if there is no successfully built executable for program.
            CL_INVALID_KERNEL_NAME if kernel_name is not found in program. -->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clCreateKernelsInProgram</name></proto>
            <param><type>cl_program</type>                              <name>program</name></param>
            <param><type>cl_uint</type>                                 <name>num_kernels</name></param>
            <param><type>cl_kernel</type>*                              <name>kernels</name></param>
            <param><type>cl_uint</type>*                                <name>num_kernels_ret</name></param>

            <if>
                <object_is_invalid name="program"/>
            </if>
            <then>      <log>program is a not a valid program object</log>
                <name>clCreateKernelsInProgram</name>                   <value>CL_INVALID_PROGRAM</value>
            </then>
            <!-- intricate but possible
            CL_INVALID_PROGRAM_EXECUTABLE if there is no successfully built executable for program.
            CL_INVALID_VALUE if kernels is not NULL and num_kernels is less than the number of kernels in program-->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clRetainKernel</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>

            <if>
                <object_is_invalid name="kernel"/>
            </if>
            <then>      <log>kernel is a not a valid kernel object</log>
                <name>clRetainKernel</name>                             <value>CL_INVALID_KERNEL</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clReleaseKernel</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>

            <if>
                <object_is_invalid name="kernel"/>
            </if>
            <then>      <log>kernel is a not a valid kernel object</log>
                <name>clReleaseKernel</name>                            <value>CL_INVALID_KERNEL</value>
            </then>
        </command>

    <!-- 5.9.2 -->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clSetKernelArg</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_uint</type>                                 <name>arg_index</name></param>
            <param><type>size_t</type>                                  <name>arg_size</name></param>
            <param>const <type>void</type>*                             <name>arg_value</name></param>

            <if>
                <object_is_invalid name="kernel"/>
            </if>
            <then>      <log>kernel is a not a valid kernel object</log>
                <name>clSetKernelArg</name>                             <value>CL_INVALID_KERNEL</value>
            </then>
            <if>
                <not>
                    <ls>
                        <name>arg_index</name>                          <query object="kernel" property="CL_KERNEL_NUM_ARGS"/>
                    </ls>
                </not>
            </if>
            <then>      <log>arg_index is not a valid argument index</log>
                <name>clSetKernelArg</name>                             <value>CL_INVALID_ARG_INDEX</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>arg_value</name>                              <name>arg_size</name>
                </array_len_ls>
            </if>
            <then>      <log>arg_value is too short</log>
                <name>clSetKernelArg</name>                             <value>CL_INVALID_ARG_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clSetKernelArgSVMPointer</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_uint</type>                                 <name>arg_index</name></param>
            <param>const <type>void</type>*                             <name>arg_value</name></param>

            <if>
                <object_is_invalid name="kernel"/>
            </if>
            <then>      <log>kernel is a not a valid kernel object</log>
                <name>clSetKernelArgSVMPointer</name>                   <value>CL_INVALID_KERNEL</value>
            </then>
            <if>
                <not>
                    <ls>
                        <name>arg_index</name>                          <query object="kernel" property="CL_KERNEL_NUM_ARGS"/>
                    </ls>
                </not>
            </if>
            <then>      <log>arg_index is not a valid argument index</log>
                <name>clSetKernelArgSVMPointer</name>                   <value>CL_INVALID_ARG_INDEX</value>
            </then>
            <if>
                <for_all in="kernel" query="CL_DEVICE_SVM_CAPABILITIES">
                    <eq>
                        <name>query</name>                              <literal>0</literal>
                    </eq>
                </for_all>
            </if>
            <then>      <log>no devices associated with kernel support SVM</log>
                <name>clSetKernelArgSVMPointer</name>                   <value>CL_INVALID_OPERATION</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clSetKernelExecInfo</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_kernel_exec_info</type>                     <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param>const <type>void</type>*                             <name>param_value</name></param>

            <if>
                <object_is_invalid name="kernel"/>
            </if>
            <then>      <log>kernel is a not a valid kernel object</log>
                <name>clSetKernelExecInfo</name>                        <value>CL_INVALID_KERNEL</value>
            </then>
            <if>
                <for_all in="kernel" query="CL_DEVICE_SVM_CAPABILITIES">
                    <eq>
                        <name>query</name>                              <literal>0</literal>
                    </eq>
                </for_all>
            </if>
            <then>      <log>no devices associated with kernel support SVM</log>
                <name>clSetKernelExecInfo</name>                        <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clSetKernelExecInfo</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <eq>
                    <name>param_value</name>                            <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>param_value is NULL</log>
                <name>clSetKernelExecInfo</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <ls>
                    <name>param_value_size</name>                       <literal_list>param_name</literal_list>
                </ls>
            </if>
            <then>      <log>the size specified by param_value_size is not valid</log>
                <name>clSetKernelExecInfo</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>param_name</name>                         <literal>CL_KERNEL_EXEC_INFO_SVM_PTRS</literal>
                    </eq>
                    <neq>
                        <mod>
                            <name>param_value_size</name>
                            <sizeof>void*</sizeof>
                        </mod>                                          <literal>0</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>the size specified by param_value_size is not valid for CL_KERNEL_EXEC_INFO_SVM_PTRS</log>
                <name>clSetKernelExecInfo</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>param_value</name>                            <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                </array_len_ls>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clSetKernelExecInfo</name>                        <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                 <struct_violation name="kernel" param="param_name, param_value"/>
            </if>
            <then>      <log>param_name is CL_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM and param_value is CL_TRUE but no devices associated with kernel support fine-grain system SVM allocations</log>
                <name>clSetKernelExecInfo</name>                        <value>CL_INVALID_OPERATION</value>
            </then>-->
        </command>

    <!-- 5.9.3 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_2_1"> <!--DONE-->
            <proto><type>cl_kernel</type>                               <name>clCloneKernel</name></proto>
            <param><type>cl_kernel</type>                               <name>source_kernel</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="source_kernel"/>
            </if>
            <then>      <log>kernel is a not a valid kernel object</log>
                <name>clCloneKernel</name>                              <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_KERNEL</value>
            </then>
        </command>

    <!-- 5.9.4 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetKernelInfo</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_kernel_info</type>                          <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="kernel"/>
            </if>
            <then>      <log>kernel is a not a valid kernel object</log>
                <name>clGetKernelInfo</name>                            <value>CL_INVALID_KERNEL</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetKernelInfo</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetKernelInfo</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetKernelInfo</name>                            <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetKernelWorkGroupInfo</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_kernel_work_group_info</type>               <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="kernel"/>
            </if>
            <then>      <log>kernel is a not a valid kernel object</log>
                <name>clGetKernelWorkGroupInfo</name>                   <value>CL_INVALID_KERNEL</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>device</name>                             <literal>NULL</literal>
                    </neq>
                    <object_not_in object="device" in="kernel"/>
                </and>
            </if>
            <then>      <log>device is not in the list of devices associated with kernel</log>
                <name>clGetKernelWorkGroupInfo</name>                   <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <struct_violation name="kernel" in="device"/>
            </if>
            <then>      <log>device is NULL but there is more than one device associated with kernel</log>
                <name>clGetKernelWorkGroupInfo</name>                   <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetKernelWorkGroupInfo</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetKernelWorkGroupInfo</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetKernelWorkGroupInfo</name>                   <value>CL_INVALID_VALUE</value>
            </then>
            <!-- need state
            CL_INVALID_VALUE if param_name is CL_KERNEL_GLOBAL_WORK_SIZE and device is not a custom device and kernel is not a built-in kernel-->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_2_1"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetKernelSubGroupInfo</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_device_id</type>                            <name>device</name></param>
            <param><type>cl_kernel_sub_group_info</type>                <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>input_value_size</name></param>
            <param>const <type>void</type>*                             <name>input_value</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="kernel"/>
            </if>
            <then>      <log>kernel is a not a valid kernel object</log>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_KERNEL</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>device</name>                             <literal>NULL</literal>
                    </neq>
                    <object_not_in object="device" in="kernel"/>
                </and>
            </if>
            <then>      <log>device is not in the list of devices associated with kernel</log>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <struct_violation name="kernel" in="device"/>
            </if>
            <then>      <log>device is NULL but there is more than one device associated with kernel</log>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>device</name>                             <literal>NULL</literal>
                    </neq>
                    <eq>
                        <literal>0</literal>                            <query object="device" property="CL_DEVICE_MAX_NUM_SUB_GROUPS"/>
                    </eq>
                </and>
            </if>
            <then>      <log>device does not support subgroups</log>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_OPERATION</value>
            </then>
            <if>
                <struct_violation name="device" in="kernel"/>
            </if>
            <then>      <log>device is NULL and device associated with kernel does not support subgroups</log>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_DEVICE</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <or>
                    <and>
                        <or>
                            <eq>
                                <name>param_name</name>                 <literal>CL_KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE</literal>
                            </eq>
                            <eq>
                                <name>param_name</name>                 <literal>CL_KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE</literal>
                            </eq>
                        </or>
                        <or>
                            <eq>
                                <name>input_value_size</name>           <literal>0</literal>
                            </eq>
                            <neq>
                                <mod>
                                    <name>input_value_size</name>
                                    <sizeof>size_t</sizeof>
                                </mod>                                  <literal>0</literal>
                            </neq>
                            <eq>
                                <name>input_value</name>                <literal>NULL</literal>
                            </eq>
                        </or>
                    </and>
                    <and>
                        <eq> <!-- special case - size of return type depends on value of param_value_size, so that it is checked here and not in the first if by literal_list -->
                            <name>param_name</name>                     <literal>CL_KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT</literal>
                        </eq>
                        <or>
                            <neq>
                                <name>input_value_size</name>           <sizeof>size_t</sizeof>
                            </neq>
                            <eq>
                                <name>input_value</name>                <literal>NULL</literal>
                            </eq>
                            <eq>
                                <name>param_value_size</name>           <literal>0</literal>
                            </eq>
                            <neq>
                                <mod>
                                    <name>param_value_size</name>
                                    <sizeof>size_t</sizeof>
                                </mod>                                  <literal>0</literal>
                            </neq>
                        </or>
                    </and>
                </or>
            </if>
            <then>      <log>param_name is CL_KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE, CL_KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE or CL_KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT and the size in bytes specified by input_value_size is not valid or if input_value is NULL</log>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not specified in standard-->
                <array_len_ls>
                    <name>input_value</name>                            <name>input_value_size</name>
                </array_len_ls>
            </if>
            <then>      <log>input_value is too short</log>
                <name>clGetKernelSubGroupInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetKernelArgInfo</name></proto>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_uint</type>                                 <name>arg_index</name></param>
            <param><type>cl_kernel_arg_info</type>                      <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="kernel"/>
            </if>
            <then>      <log>kernel is a not a valid kernel object</log>
                <name>clGetKernelArgInfo</name>                         <value>CL_INVALID_KERNEL</value>
            </then>
            <if>
                <not>
                    <ls>
                        <name>arg_index</name>                          <query object="kernel" property="CL_KERNEL_NUM_ARGS"/>
                    </ls>
                </not>
            </if>
            <then>      <log>arg_index is not a valid argument index</log>
                <name>clGetKernelArgInfo</name>                         <value>CL_INVALID_ARG_INDEX</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetKernelArgInfo</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetKernelArgInfo</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetKernelArgInfo</name>                         <value>CL_INVALID_VALUE</value>
            </then>
        </command>

    <!-- 5.10 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueNDRangeKernel</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_uint</type>                                 <name>work_dim</name></param>
            <param>const <type>size_t</type>*                           <name>global_work_offset</name></param>
            <param>const <type>size_t</type>*                           <name>global_work_size</name></param>
            <param>const <type>size_t</type>*                           <name>local_work_size</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="kernel"/>
            </if>
            <then>      <log>kernel is a not a valid kernel object</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_KERNEL</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="kernel"/>
            </if>
            <then>      <log>context associated with command_queue and kernel are not the same</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="kernel" in="command_queue"/>
            </if>
            <then>      <log>there is no successfully built program executable available for device associated with command_queue</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_PROGRAM_EXECUTABLE</value>
            </then>
            <if>
                <eq>
                    <name>work_dim</name>                               <literal>0</literal>
                </eq>
            </if>
            <then>      <log>work_dim is 0</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_WORK_DIMENSION</value>
            </then>
            <if>
                <gt>
                    <name>work_dim</name>                               <query object="command_queue" property="CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS"/>
                </gt>
            </if>
            <then>      <log>work_dim is larger than CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_WORK_DIMENSION</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>global_work_size</name>                   <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>global_work_size</name>                   <name>work_dim</name>
                    </array_len_ls>
                </and>
            </if>
            <then>     <log>global_work_size is too short</log> 
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <not>
                        <from version="2.1"/>
                    </not>
                    <or>
                        <eq>
                            <name>global_work_size</name>               <literal>NULL</literal>
                        </eq>
                        <any_zero array="global_work_size" elements="work_dim"/>
                    </or>
                </and>
            </if>
            <then>      <log>OpenCL version is less than 2.1 and global_work_size is NULL or some of the values specified in global_work_size are 0</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_GLOBAL_WORK_SIZE</value>
            </then>
            <if>
                <and>
                    <not>
                        <from version="1.1"/>
                    </not>
                    <neq>
                        <name>global_work_offset</name>                 <literal>NULL</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>OpenCL version is less than 1.1 and global_work_offset is not NULL</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_GLOBAL_OFFSET</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>global_work_offset</name>                 <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>global_work_offset</name>                 <name>work_dim</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>global_work_offset is too short</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>local_work_size</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>local_work_size</name>                    <name>work_dim</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>local_work_size is too short</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <struct_violation name="kernel" param="command_queue, work_dim, local_work_size"/>
            </if>
            <then>      <log>local_work_size is specified and the total number of work-items in the work-group is greater than the value specified by CL_KERNEL_WORK_GROUP_SIZE</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_WORK_GROUP_SIZE</value>
            </then>
            <if>
                <struct_violation name="command_queue" param="kernel, work_dim, global_work_size, local_work_size"/>
            </if>
            <then>      <log>the work-group size must be uniform and the local_work_size is not NULL, is not equal to the required work-group size specified in the kernel source, or the global_work_size is not evenly divisible by the local_work_size</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_WORK_GROUP_SIZE</value>
            </then>
            <if>
                <struct_violation name="command_queue" param="kernel, work_dim, local_work_size"/>
            </if>
            <then>      <log>local_work_size is specified and is not consistent with the required number of sub-groups for kernel in the program source</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_WORK_GROUP_SIZE</value>
            </then>
            <if>
                <struct_violation name="command_queue" param="work_dim, local_work_size"/>
            </if>
            <then>      <log>the number of work-items specified in some of local_work_size is greater than the corresponding values specified by CL_DEVICE_MAX_WORK_ITEM_SIZES</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_WORK_ITEM_SIZE</value>
            </then>
            <!-- CL_INVALID_GLOBAL_WORK_SIZE if any of the values specified in global_work_size[0], ... global_work_size[work_dim - 1] exceed the maximum value representable by size_t on the device on which the kernel-instance will be enqueued. -->
            <!-- CL_INVALID_GLOBAL_OFFSET if the value specified in global_work_size + the corresponding values in global_work_offset for any dimensions is greater than the maximum value representable by size t on the device on which the kernel-instance will be enqueued. -->
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueNDRangeKernel</name>                     <value>CL_INVALID_CONTEXT</value>
            </then>
            <!-- need state
            CL_INVALID_KERNEL_ARGS if the kernel argument values have not been specified.
            CL_MISALIGNED_SUB_BUFFER_OFFSET if a sub-buffer object is specified as the value for an argument that is a buffer object and the offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue. This error code is missing before version 1.1.
            CL_INVALID_IMAGE_SIZE if an image object is specified as an argument value and the image dimensions (image width, height, specified or compute row and/or slice pitch) are not supported by device associated with queue.
            CL_IMAGE_FORMAT_NOT_SUPPORTED if an image object is specified as an argument value and the image format (image channel order and data type) is not supported by device associated with queue
            CL_INVALID_OPERATION if SVM pointers are passed as arguments to a kernel and the device does not support SVM or if system pointers are passed as arguments to a kernel and/or stored inside SVM allocations passed as kernel arguments and the device does not support fine grain system SVM allocations.-->
            <!-- CL_OUT_OF_RESOURCES if there is a failure to queue the execution instance of kernel on the command-queue because of insufficient resources needed to execute the kernel. For example, the explicitly specified local_work_size causes a failure to execute the kernel because of insufficient resources such as registers or local memory. Another example would be the number of read-only image args used in kernel exceed the CL_DEVICE_MAX_READ_IMAGE_ARGS value for device or the number of write-only and read-write image args used in kernel exceed the CL_DEVICE_MAX_READ_WRITE_IMAGE_ARGS value for device or the number of samplers used in kernel exceed CL_DEVICE_MAX_SAMPLERS for device -->
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_2_DEPRECATED"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueTask</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_kernel</type>                               <name>kernel</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueTask</name>                              <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueTask</name>                              <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <object_is_invalid name="kernel"/>
            </if>
            <then>      <log>kernel is a not a valid kernel object</log>
                <name>clEnqueueTask</name>                              <value>CL_INVALID_KERNEL</value>
            </then>
            <if>
                <object_not_in object="command_queue" in="kernel"/>
            </if>
            <then>      <log>context associated with command_queue and kernel are not the same</log>
                <name>clEnqueueTask</name>                              <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <object_not_in object="kernel" in="command_queue"/>
            </if>
            <then>      <log>there is no successfully built program executable available for device associated with command_queue</log>
                <name>clEnqueueTask</name>                              <value>CL_INVALID_PROGRAM_EXECUTABLE</value>
            </then>
            <if>
                <struct_violation name="command_queue" param="kernel"/>
            </if>
            <then>      <log>a work-group size is specified for kernel in the program source and it is not (1, 1, 1) or the required number of sub-groups is specified for kernel in the program source and is not consistent with a work-group size of (1, 1, 1)</log>
                <name>clEnqueueTask</name>                              <value>CL_INVALID_WORK_GROUP_SIZE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueTask</name>                              <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueTask</name>                              <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueTask</name>                              <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueTask</name>                              <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueTask</name>                              <value>CL_INVALID_CONTEXT</value>
            </then>
            <!-- need state
            CL_INVALID_KERNEL_ARGS if the kernel argument values have not been specified.
            CL_MISALIGNED_SUB_BUFFER_OFFSET if a sub-buffer object is specified as the value for an argument that is a buffer object and the offset specified when the sub-buffer object is created is not aligned to CL_DEVICE_MEM_BASE_ADDR_ALIGN value for device associated with queue. This error code is missing before version 1.1.
            CL_INVALID_IMAGE_SIZE if an image object is specified as an argument value and the image dimensions (image width, height, specified or compute row and/or slice pitch) are not supported by device associated with queue.
            CL_IMAGE_FORMAT_NOT_SUPPORTED if an image object is specified as an argument value and the image format (image channel order and data type) is not supported by device associated with queue
            CL_INVALID_OPERATION if SVM pointers are passed as arguments to a kernel and the device does not support SVM or if system pointers are passed as arguments to a kernel and/or stored inside SVM allocations passed as kernel arguments and the device does not support fine grain system SVM allocations.-->
            <!-- CL_OUT_OF_RESOURCES if there is a failure to queue the execution instance of kernel on the command-queue because of insufficient resources needed to execute the kernel. For example, the explicitly specified local_work_size causes a failure to execute the kernel because of insufficient resources such as registers or local memory. Another example would be the number of read-only image args used in kernel exceed the CL_DEVICE_MAX_READ_IMAGE_ARGS value for device or the number of write-only and read-write image args used in kernel exceed the CL_DEVICE_MAX_READ_WRITE_IMAGE_ARGS value for device or the number of samplers used in kernel exceed CL_DEVICE_MAX_SAMPLERS for device -->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueNativeKernel</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param>void (CL_CALLBACK*                                   <name>user_func</name>)(void*)</param>
            <param><type>void</type>*                                   <name>args</name></param>
            <param><type>size_t</type>                                  <name>cb_args</name></param>
            <param><type>cl_uint</type>                                 <name>num_mem_objects</name></param>
            <param>const <type>cl_mem</type>*                           <name>mem_list</name></param>
            <param>const <type>void</type>**                            <name>args_mem_loc</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <eq>
                    <name>user_func</name>                              <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>user_func is NULL</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>args</name>                               <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>cb_args</name>                            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>args is a NULL value and cb_args &gt; 0</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>args</name>                               <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_mem_objects</name>                    <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then><log>args is a NULL value and num_mem_objects &gt; 0</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>args</name>                               <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>cb_args</name>                            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>args is not NULL and cb_args is 0</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <gt>
                        <name>num_mem_objects</name>                    <literal>0</literal>
                    </gt>
                    <or>
                        <eq>
                            <name>mem_list</name>                       <literal>NULL</literal>
                        </eq>
                        <eq>
                            <name>args_mem_loc</name>                   <literal>NULL</literal>
                        </eq>
                    </or>
                </and>
            </if>
            <then>      <log>num_mem_objects &gt; 0 and mem_list or args_mem_loc are NULL</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>num_mem_objects</name>                    <literal>0</literal>
                    </eq>
                    <or>
                        <neq>
                            <name>mem_list</name>                       <literal>NULL</literal>
                        </neq>
                        <neq>
                            <name>args_mem_loc</name>                   <literal>NULL</literal>
                        </neq>
                    </or>
                </and>
            </if>
            <then>      <log>num_mem_objects = 0 and mem_list or args_mem_loc are not NULL</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>args</name>                               <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>args</name>                               <name>cb_args</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>args is too short</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <gt>
                        <name>num_mem_objects</name>                    <literal>0</literal>
                    </gt>
                    <or>
                        <array_len_ls>
                            <name>mem_list</name>                       <name>num_mem_objects</name>
                        </array_len_ls>
                        <array_len_ls>
                            <name>args_mem_loc</name>                   <name>num_mem_objects</name>
                        </array_len_ls>
                    </or>
                </and>
            </if>
            <then>      <log>mem_list or args_mem_loc is too short</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <struct_violation name="mem_list" param="num_mem_objects"/>
            </if>
            <then>      <log>one or more non-NULL memory objects specified in mem_list are not valid buffers</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_MEM_OBJECT</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_CONTEXT</value>
            </then>
            <if>
                <not>
                    <bit_and>
                        <literal>CL_EXEC_NATIVE_KERNEL</literal>        <query object="command_queue" property="CL_DEVICE_EXECUTION_CAPABILITIES"/>
                    </bit_and>
                </not>
            </if>
            <then>      <log>the device associated with command_queue cannot execute the native kernel</log>
                <name>clEnqueueNativeKernel</name>                      <value>CL_INVALID_OPERATION</value>
            </then>
            <!-- need state
            CL_INVALID_OPERATION if SVM pointers are passed as arguments to a kernel and the device does not support SVM or if system pointers are passed as arguments to a kernel and/or stored inside SVM allocations passed as kernel arguments and the device does not support fine grain system SVM allocations.-->
        </command>

    <!-- 5.11 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_1"> <!--DONE-->
            <proto><type>cl_event</type>                                <name>clCreateUserEvent</name></proto>
            <param><type>cl_context</type>                              <name>context</name></param>
            <param><type>cl_int</type>*                                 <name>errcode_ret</name></param>

            <if>
                <object_is_invalid name="context"/>
            </if>
            <then>      <log>context is not a valid context</log>
                <name>clCreateUserEvent</name>                          <value>NULL</value>
                <name>errcode_ret</name>                                <value>CL_INVALID_CONTEXT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clSetUserEventStatus</name></proto>
            <param><type>cl_event</type>                                <name>event</name></param>
            <param><type>cl_int</type>                                  <name>execution_status</name></param>

            <if>
                <object_is_invalid name="event"/>
            </if>
            <then>      <log>event is not a valid event object</log>
                <name>clSetUserEventStatus</name>                       <value>CL_INVALID_EVENT</value>
            </then>
            <if>
                <object_is_invalid name="event" type="CL_COMMAND_USER"/>
            </if>
            <then>      <log>event is not a valid user event object</log>
                <name>clSetUserEventStatus</name>                       <value>CL_INVALID_EVENT</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>execution_status</name>                   <literal>CL_COMPLETE</literal>
                    </neq>
                    <gt>
                        <name>execution_status</name>                   <literal>-1</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>the execution_status is not CL_COMPLETE or a negative integer value</log>
                <name>clSetUserEventStatus</name>                       <value>CL_INVALID_VALUE</value>
            </then>
            <!-- need state
            CL_INVALID_OPERATION if the execution_status for event has already been changed by a previous call to clSetUserEventStatus-->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clWaitForEvents</name></proto>
            <param><type>cl_uint</type>                                 <name>num_events</name></param>
            <param>const <type>cl_event</type>*                         <name>event_list</name></param>

            <if>
                <or>
                    <eq>
                        <name>num_events</name>                         <literal>0</literal>
                    </eq>
                    <eq>
                        <name>event_list</name>                         <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>num_events is zero or event_list is NULL</log>
                <name>clWaitForEvents</name>                            <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>event_list</name>                             <name>num_events</name>
                </array_len_ls>
            </if>
            <then>      <log>event_list is too short</log>
                <name>clWaitForEvents</name>                            <value>CL_INVALID_EVENT</value>
            </then>
            <if>
                <any_invalid array="event_list" elements="num_events"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clWaitForEvents</name>                            <value>CL_INVALID_EVENT</value>
            </then>
            <if>
                <any_object_not_in array="event_list" elements="num_events" in="event_list[0]"/>
            </if>
            <then>      <log>events specified in event_list do not belong to the same context</log>
                <name>clWaitForEvents</name>                            <value>CL_INVALID_CONTEXT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetEventInfo</name></proto>
            <param><type>cl_event</type>                                <name>event</name></param>
            <param><type>cl_event_info</type>                           <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="event"/>
            </if>
            <then>      <log>event is not a valid event object</log>
                <name>clGetEventInfo</name>                             <value>CL_INVALID_EVENT</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetEventInfo</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetEventInfo</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetEventInfo</name>                             <value>CL_INVALID_VALUE</value>
            </then>
            <!-- need state
            CL_INVALID_VALUE if information to query given in param_name cannot be queried for event -->
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_1"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clSetEventCallback</name></proto>
            <param><type>cl_event</type>                                <name>event</name></param>
            <param><type>cl_int</type>                                  <name>command_exec_callback_type</name></param>
            <param>void (CL_CALLBACK*                                   <name>pfn_event_notify</name>)(cl_event event, cl_int event_command_status, void *user_data)</param>
            <param><type>void</type>*                                   <name>user_data</name></param>

            <if>
                <object_is_invalid name="event"/>
            </if>
            <then>      <log>event is not a valid event object</log>
                <name>clSetEventCallback</name>                         <value>CL_INVALID_EVENT</value>
            </then>
            <if>
                <eq>
                    <name>pfn_event_notify</name>                       <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>pfn_event_notify is NULL</log>
                <name>clSetEventCallback</name>                         <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>command_exec_callback_type</name>         <literal>CL_SUBMITTED</literal>
                    </neq>
                    <neq>
                        <name>command_exec_callback_type</name>         <literal>CL_RUNNING</literal>
                    </neq>
                    <neq>
                        <name>command_exec_callback_type</name>         <literal>CL_COMPLETE</literal>
                    </neq>
                </and>
            </if>
            <then>      <log>command_exec_callback_type is not CL_SUBMITTED, CL_RUNNING, or CL_COMPLETE</log>
                <name>clSetEventCallback</name>                         <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clRetainEvent</name></proto>
            <param><type>cl_event</type>                                <name>event</name></param>

            <if>
                <object_is_invalid name="event"/>
            </if>
            <then>      <log>event is not a valid event object</log>
                <name>clRetainEvent</name>                              <value>CL_INVALID_EVENT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clReleaseEvent</name></proto>
            <param><type>cl_event</type>                                <name>event</name></param>

            <if>
                <object_is_invalid name="event"/>
            </if>
            <then>      <log>event is not a valid event object</log>
                <name>clReleaseEvent</name>                             <value>CL_INVALID_EVENT</value>
            </then>
        </command>

    <!-- 5.12 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueMarkerWithWaitList</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueMarkerWithWaitList</name>                <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueMarkerWithWaitList</name>                <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueMarkerWithWaitList</name>                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueMarkerWithWaitList</name>                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueMarkerWithWaitList</name>                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueMarkerWithWaitList</name>                <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueMarkerWithWaitList</name>                <value>CL_INVALID_CONTEXT</value>
            </then>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_1_DEPRECATED"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueMarker</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueMarker</name>                            <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueMarker</name>                            <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <eq>
                    <name>event</name>                                  <literal>NULL</literal>
                </eq>
            </if>
            <then>      <log>event is NULL</log>
                <name>clEnqueueMarker</name>                            <value>CL_INVALID_VALUE</value>
            </then>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_1_DEPRECATED"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueWaitForEvents</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_uint</type>                                 <name>num_events</name></param>
            <param>const <type>cl_event</type>*                         <name>event_list</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueWaitForEvents</name>                     <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueWaitForEvents</name>                     <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <or>
                    <eq>
                        <name>num_events</name>                         <literal>0</literal>
                    </eq>
                    <eq>
                        <name>event_list</name>                         <literal>NULL</literal>
                    </eq>
                </or>
            </if>
            <then>      <log>num_events is 0 or event_list is NULL</log>
                <name>clEnqueueWaitForEvents</name>                     <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <array_len_ls>
                    <name>event_list</name>                             <name>num_events</name>
                </array_len_ls>
            </if>
            <then>       <log>event_list is too short</log>
                <name>clEnqueueWaitForEvents</name>                     <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <any_object_not_in array="event_list" elements="num_events" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueWaitForEvents</name>                     <value>CL_INVALID_CONTEXT</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_2"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueBarrierWithWaitList</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>
            <param><type>cl_uint</type>                                 <name>num_events_in_wait_list</name></param>
            <param>const <type>cl_event</type>*                         <name>event_wait_list</name></param>
            <param><type>cl_event</type>*                               <name>event</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueBarrierWithWaitList</name>               <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueBarrierWithWaitList</name>               <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <and>
                    <eq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </eq>
                    <gt>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </gt>
                </and>
            </if>
            <then>      <log>event_wait_list is NULL and num_events_in_wait_list > 0</log>
                <name>clEnqueueBarrierWithWaitList</name>               <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <eq>
                        <name>num_events_in_wait_list</name>            <literal>0</literal>
                    </eq>
                </and>
            </if>
            <then>      <log>event_wait_list is not NULL and num_events_in_wait_list is 0</log>
                <name>clEnqueueBarrierWithWaitList</name>               <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>event_wait_list</name>                    <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>event_wait_list</name>                    <name>num_events_in_wait_list</name>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>event_wait_list is too short</log>
                <name>clEnqueueBarrierWithWaitList</name>               <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_invalid array="event_wait_list" elements="num_events_in_wait_list"/>
            </if>
            <then>      <log>event objects in event_wait_list are not valid events</log>
                <name>clEnqueueBarrierWithWaitList</name>               <value>CL_INVALID_EVENT_WAIT_LIST</value>
            </then>
            <if>
                <any_object_not_in array="event_wait_list" elements="num_events_in_wait_list" in="command_queue"/>
            </if>
            <then>      <log>the context associated with command_queue and events in event_wait_list are not the same</log>
                <name>clEnqueueBarrierWithWaitList</name>               <value>CL_INVALID_CONTEXT</value>
            </then>
        </command>

        <command prefix="CL_API_PREFIX__VERSION_1_1_DEPRECATED" suffix="CL_API_SUFFIX__VERSION_1_1_DEPRECATED"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clEnqueueBarrier</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clEnqueueBarrier</name>                           <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clEnqueueBarrier</name>                           <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
        </command>

    <!-- 5.14 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clGetEventProfilingInfo</name></proto>
            <param><type>cl_event</type>                                <name>event</name></param>
            <param><type>cl_profiling_info</type>                       <name>param_name</name></param>
            <param><type>size_t</type>                                  <name>param_value_size</name></param>
            <param><type>void</type>*                                   <name>param_value</name></param>
            <param><type>size_t</type>*                                 <name>param_value_size_ret</name></param>

            <if>
                <object_is_invalid name="event"/>
            </if>
            <then>      <log>event is not a valid event object</log>
                <name>clGetEventProfilingInfo</name>                    <value>CL_INVALID_EVENT</value>
            </then>
            <if>
                <enum_violation name="param_name"/>
            </if>
            <then>      <log>param_name is not valid</log>
                <name>clGetEventProfilingInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <ls>
                        <name>param_value_size</name>                   <literal_list>param_name</literal_list>
                    </ls>
                </and>
            </if>
            <then>      <log>size in bytes specified by param_value_size is &lt; size of return type and param_value is not NULL</log>
                <name>clGetEventProfilingInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if> <!-- not covered by standard-->
                <and>
                    <neq>
                        <name>param_value</name>                        <literal>NULL</literal>
                    </neq>
                    <array_len_ls>
                        <name>param_value</name>                        <max>
                                                                            <literal_list>param_name</literal_list>
                                                                            <name>param_value_size</name>
                                                                        </max>
                    </array_len_ls>
                </and>
            </if>
            <then>      <log>param_value is too short</log>
                <name>clGetEventProfilingInfo</name>                    <value>CL_INVALID_VALUE</value>
            </then>
            <if>
                <not>
                    <bit_and>
                        <literal>CL_QUEUE_PROFILING_ENABLE</literal>    <query object="event" property="CL_QUEUE_PROPERTIES"/>
                    </bit_and>
                </not>
            </if>
            <then>      <log>the CL_QUEUE_PROFILING_ENABLE flag is not set for the command-queue</log>
                <name>clGetEventProfilingInfo</name>                    <value>CL_PROFILING_INFO_NOT_AVAILABLE</value>
            </then>
            <if>
                <not>
                    <object_is_invalid name="event" type="CL_COMMAND_USER"/>
                </not>
            </if>
            <then>      <log>event is a user event object</log>
                <name>clGetEventProfilingInfo</name>                    <value>CL_PROFILING_INFO_NOT_AVAILABLE</value>
            </then>
        </command>

    <!-- 5.15 --> <!--DONE-->

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clFlush</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clFlush</name>                                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clFlush</name>                                    <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
        </command>

        <command suffix="CL_API_SUFFIX__VERSION_1_0"> <!--DONE-->
            <proto><type>cl_int</type>                                  <name>clFinish</name></proto>
            <param><type>cl_command_queue</type>                        <name>command_queue</name></param>

            <if>
                <object_is_invalid name="command_queue"/>
            </if>
            <then>      <log>command_queue is not a valid command-queue</log>
                <name>clFinish</name>                                   <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
            <if>
                <bit_and>
                    <literal>CL_QUEUE_ON_DEVICE</literal>               <query object="command_queue" property="CL_QUEUE_PROPERTIES"/>
                </bit_and>
            </if>
            <then>      <log>command_queue is not a host command-queue</log>
                <name>clFinish</name>                                   <value>CL_INVALID_COMMAND_QUEUE</value>
            </then>
        </command>
    </commands>

</registry>
